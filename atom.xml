<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://caijh.github.io/</id>
    <title>John&apos;s Blog</title>
    <updated>2019-08-06T03:36:59.742Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://caijh.github.io/"/>
    <link rel="self" href="https://caijh.github.io//atom.xml"/>
    <subtitle>搬砖小弟</subtitle>
    <logo>https://caijh.github.io//images/avatar.png</logo>
    <icon>https://caijh.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, John&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Maven - 怎么样skip test]]></title>
        <id>https://caijh.github.io//post/maven-zen-me-yang-skip-test</id>
        <link href="https://caijh.github.io//post/maven-zen-me-yang-skip-test">
        </link>
        <updated>2019-08-06T03:20:36.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="maven-参数设置">Maven 参数设置</h3>
<ul>
<li>使用参数-Dmaven.test.skip=true</li>
<li>在pom.xml中定义参数<br>
<code>&lt;properties&gt; &lt;maven.test.skip&gt;true&lt;/maven.test.skip&gt; &lt;/properties&gt;</code></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h3 id="maven-参数设置">Maven 参数设置</h3>
<ul>
<li>使用参数-Dmaven.test.skip=true</li>
<li>在pom.xml中定义参数<br>
<code>&lt;properties&gt; &lt;maven.test.skip&gt;true&lt;/maven.test.skip&gt; &lt;/properties&gt;</code></li>
</ul>
<!-- more -->
<h3 id="maven-surefire-plugin">Maven Surefire Plugin</h3>
<pre><code>mvn package -DskipTests
</code></pre>
<p>or</p>
<pre><code>&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.0.0-M1&lt;/version&gt;
    &lt;configuration&gt;
        &lt;skipTests&gt;true&lt;/skipTests&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot - 启动原理]]></title>
        <id>https://caijh.github.io//post/springboot-qi-dong-yuan-li</id>
        <link href="https://caijh.github.io//post/springboot-qi-dong-yuan-li">
        </link>
        <updated>2019-07-20T03:41:54.000Z</updated>
        <summary type="html"><![CDATA[<p>SpringBoot应用启动类一般如下：</p>
<pre><code>@SpringBootApplication
public class SampleRabbitmqApplication {

    public static void main(String[] args) {
        SpringApplication.run(SampleRabbitmqApplication.class, args);
    }

}
</code></pre>
<h1 id="springbootapplication">@SpringBootApplication</h1>
<p>@SpringBootApplication这个组合注解包含了三个注解 ：</p>
<ul>
<li>@SpringBootConfiguration</li>
<li>@EnableAutoConfiguration</li>
<li>@ComponentScan</li>
</ul>
<p>@SpringBootConfiguration实际上应用@Configuration， 任何注解了Configuration了java类都是一个JavaConfig配置类。<br>
@ComponentScan的功能是自动扫描并加载符合条件的组件（如@Component和@Repository）,最终将这些bean加载IoC容器中。<br>
@EnableAutoConfiguration借助@Import收集和注册特定场景相关的bean定义。</p>
]]></summary>
        <content type="html"><![CDATA[<p>SpringBoot应用启动类一般如下：</p>
<pre><code>@SpringBootApplication
public class SampleRabbitmqApplication {

    public static void main(String[] args) {
        SpringApplication.run(SampleRabbitmqApplication.class, args);
    }

}
</code></pre>
<h1 id="springbootapplication">@SpringBootApplication</h1>
<p>@SpringBootApplication这个组合注解包含了三个注解 ：</p>
<ul>
<li>@SpringBootConfiguration</li>
<li>@EnableAutoConfiguration</li>
<li>@ComponentScan</li>
</ul>
<p>@SpringBootConfiguration实际上应用@Configuration， 任何注解了Configuration了java类都是一个JavaConfig配置类。<br>
@ComponentScan的功能是自动扫描并加载符合条件的组件（如@Component和@Repository）,最终将这些bean加载IoC容器中。<br>
@EnableAutoConfiguration借助@Import收集和注册特定场景相关的bean定义。</p>
<!-- more -->
<pre><code>@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import(AutoConfigurationImportSelector.class)
public @interface EnableAutoConfiguration {

	String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;

	/**
	 * Exclude specific auto-configuration classes such that they will never be applied.
	 * @return the classes to exclude
	 */
	Class&lt;?&gt;[] exclude() default {};

	/**
	 * Exclude specific auto-configuration class names such that they will never be
	 * applied.
	 * @return the class names to exclude
	 * @since 1.3.0
	 */
	String[] excludeName() default {};

}
</code></pre>
<p>@Import(AutoConfigurationImportSelector.class)中借助AutoConfigurationImportSelector可以帮助SpringBoot应用将所有符合@Configuration配置都加载到当SpringBoot创建IoC容器中。AutoConfigurationImportSelector使用SpringFactoriesLoader从META-INF/spring.factories加载配置。</p>
<h4 id="springapplicationrun">SpringApplication.run</h4>
<pre><code>public ConfigurableApplicationContext run(String... args) {
		StopWatch stopWatch = new StopWatch();
		stopWatch.start();
		ConfigurableApplicationContext context = null;
		Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();
		configureHeadlessProperty();
		SpringApplicationRunListeners listeners = getRunListeners(args);
		listeners.starting();
		try {
			ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
			ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);
			configureIgnoreBeanInfo(environment);
			Banner printedBanner = printBanner(environment);
			context = createApplicationContext();
			exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,
					new Class[] { ConfigurableApplicationContext.class }, context);
			prepareContext(context, environment, listeners, applicationArguments, printedBanner);
			refreshContext(context);
			afterRefresh(context, applicationArguments);
			stopWatch.stop();
			if (this.logStartupInfo) {
				new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);
			}
			listeners.started(context);
			callRunners(context, applicationArguments);
		}
		catch (Throwable ex) {
			handleRunFailure(context, ex, exceptionReporters, listeners);
			throw new IllegalStateException(ex);
		}

		try {
			listeners.running(context);
		}
		catch (Throwable ex) {
			handleRunFailure(context, ex, exceptionReporters, null);
			throw new IllegalStateException(ex);
		}
		return context;
	}
</code></pre>
<ol>
<li>创建SpringApplicationRunListeners, 获取SpringFactoriesInstances实例</li>
<li>准备环境变量</li>
<li>是否打印banner</li>
<li>创建ApplicationContext,servelt环境创建AnnotationConfigServletWebServerApplicationContext， reactive环境创建AnnotationConfigReactiveWebServerApplicationContext， 否则创建AnnotationConfigApplicationContext</li>
<li>prepareContext, 主要是ApplicationContextInitializer的初始化</li>
<li>refreshContext 调用ApplicationContext的refresh()方法</li>
<li>afterRefresh, 空方法</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis - 编译纯净版]]></title>
        <id>https://caijh.github.io//post/redis-bian-yi-chun-jing-ban</id>
        <link href="https://caijh.github.io//post/redis-bian-yi-chun-jing-ban">
        </link>
        <updated>2019-07-18T07:38:08.000Z</updated>
        <summary type="html"><![CDATA[<p>按redis官网编译的redis, 可执行文件会与源码在一起, 如果想编译纯净版可按下边的步骤。</p>
]]></summary>
        <content type="html"><![CDATA[<p>按redis官网编译的redis, 可执行文件会与源码在一起, 如果想编译纯净版可按下边的步骤。</p>
<!-- more -->
<h3 id="下载redis">下载redis</h3>
<pre><code>$ wget http://download.redis.io/releases/redis-5.0.5.tar.gz
$ tar xzf redis-5.0.5.tar.gz
$ cd redis-5.0.5
</code></pre>
<h3 id="make-指定rpefix值">make 指定RPEFIX值</h3>
<pre><code>make PREFIX=~/dev/redis-5.0.5 install
</code></pre>
<h3 id="复制配置文件到安装目录">复制配置文件到安装目录</h3>
<pre><code>➜  redis-5.0.5 cp redis.conf ~/dev/redis-5.0.5 
➜  redis-5.0.5 cp sentinel.conf ~/dev/redis-5.0.5
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis - 如何访问大量数据]]></title>
        <id>https://caijh.github.io//post/redis-ru-he-fang-wen-da-liang-shu-ju</id>
        <link href="https://caijh.github.io//post/redis-ru-he-fang-wen-da-liang-shu-ju">
        </link>
        <updated>2019-07-18T04:31:22.000Z</updated>
        <summary type="html"><![CDATA[<p>众如周知，Redis中<code>keys pattern</code>命令可以返回大量数据。<br>
非生产环境可以结合linux的管道删除相同pattern的key.</p>
<pre><code>redis-cli keys &quot;*&quot; | xargs redis-cli del
</code></pre>
<p>但是生产环境一般keys会被重命名禁止在生产使用。<br>
这时可以使用scan命令删除。</p>
]]></summary>
        <content type="html"><![CDATA[<p>众如周知，Redis中<code>keys pattern</code>命令可以返回大量数据。<br>
非生产环境可以结合linux的管道删除相同pattern的key.</p>
<pre><code>redis-cli keys &quot;*&quot; | xargs redis-cli del
</code></pre>
<p>但是生产环境一般keys会被重命名禁止在生产使用。<br>
这时可以使用scan命令删除。</p>
<!-- more -->
<p>scan的特点：</p>
<ul>
<li>复杂度虽然也是 O(n)，但是它是通过游标分步进行的，不会阻塞线程</li>
<li>提供 count 参数，不是结果数量，是Redis单次遍历字典槽位数量(约等于)</li>
<li>同 keys 一样，它也提供模式匹配功能;</li>
<li>服务器不需要为游标保存状态，游标的唯一状态就是 scan 返回给客户端的游标整数;</li>
<li>返回的结果可能会有重复，需要客户端去重复，这点非常重要;</li>
<li>单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为零</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis - 缓存问题]]></title>
        <id>https://caijh.github.io//post/redis-huan-cun-wen-ti</id>
        <link href="https://caijh.github.io//post/redis-huan-cun-wen-ti">
        </link>
        <updated>2019-07-18T03:42:55.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="缓存穿透">缓存穿透</h3>
<blockquote>
<p>什么是缓存穿透？<br>
缓存穿透是指查询一个一定不在缓存中存在的key. 由于key不存在，每次都会去查询数据库，如果对于这个key的请求很多的话，可能会把数据库搞垮。</p>
</blockquote>
<p>解决方案：</p>
<ol>
<li>布隆过滤器</li>
<li>将查询数据库的空结果也缓存起来，设置一个较短的过期时间。</li>
</ol>
<h3 id="缓存雪崩">缓存雪崩</h3>
<blockquote>
<p>什么是缓存雪崩？<br>
对于多个key的查询，全部请求都走数据库了。有两种情况：一种是redis挂掉，别一个情况是一段时间内那些key都失效了。<br>
对于第一种情况要保证redis的的高可性，对于第二种情况可以为key设置不同的随随机过期时间。</p>
</blockquote>
<h3 id="缓存数据一致性">缓存数据一致性</h3>
<ol>
<li>写数据库也写缓存，保证了数据一致性；但是难保证数据库与redis的事务</li>
<li>写数据库，直接删缓存；读缓存发现没有，从数据库读取并保存缓存；带来问题是并发问题。</li>
<li>应该根据不同的业务，来处理缓存的生成。</li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<h3 id="缓存穿透">缓存穿透</h3>
<blockquote>
<p>什么是缓存穿透？<br>
缓存穿透是指查询一个一定不在缓存中存在的key. 由于key不存在，每次都会去查询数据库，如果对于这个key的请求很多的话，可能会把数据库搞垮。</p>
</blockquote>
<p>解决方案：</p>
<ol>
<li>布隆过滤器</li>
<li>将查询数据库的空结果也缓存起来，设置一个较短的过期时间。</li>
</ol>
<h3 id="缓存雪崩">缓存雪崩</h3>
<blockquote>
<p>什么是缓存雪崩？<br>
对于多个key的查询，全部请求都走数据库了。有两种情况：一种是redis挂掉，别一个情况是一段时间内那些key都失效了。<br>
对于第一种情况要保证redis的的高可性，对于第二种情况可以为key设置不同的随随机过期时间。</p>
</blockquote>
<h3 id="缓存数据一致性">缓存数据一致性</h3>
<ol>
<li>写数据库也写缓存，保证了数据一致性；但是难保证数据库与redis的事务</li>
<li>写数据库，直接删缓存；读缓存发现没有，从数据库读取并保存缓存；带来问题是并发问题。</li>
<li>应该根据不同的业务，来处理缓存的生成。</li>
</ol>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis - 数据淘汰策略]]></title>
        <id>https://caijh.github.io//post/redis-shu-ju-tao-tai-ce-lue</id>
        <link href="https://caijh.github.io//post/redis-shu-ju-tao-tai-ce-lue">
        </link>
        <updated>2019-07-18T03:08:46.000Z</updated>
        <summary type="html"><![CDATA[<ul>
<li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li>
<li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li>no-enviction（驱逐）：禁止驱逐数据，返回错误</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<ul>
<li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li>
<li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li>no-enviction（驱逐）：禁止驱逐数据，返回错误</li>
</ul>
<!-- more -->
<h3 id="参数设置">参数设置</h3>
<p>Redis中存在一个参数用来设定内存使用上限，这个参数是maxmemory，可以在redis.conf中设置redis内存使用的最大值，当redis使用内存达到最大值时，redis会根据配置文件中的策略选取要删除的key，并删除这些key-value的值。若根据配置的策略，没有符合策略的key，也就是说内存已经容不下新的key-value了，但此时有不能删除key，那么这时候写的话，将会出现写错误。</p>
<h3 id="何时触发内存淘汰">何时触发内存淘汰</h3>
<ol>
<li>客户端发送指令，导致数据的增加时</li>
<li>redis检测到内存的使用达到上限</li>
<li>redis自身执行指令时</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vagrant - 使用]]></title>
        <id>https://caijh.github.io//post/vagrant-shi-yong</id>
        <link href="https://caijh.github.io//post/vagrant-shi-yong">
        </link>
        <updated>2019-07-17T14:11:55.000Z</updated>
        <summary type="html"><![CDATA[<p>Vagrant是用来管理虚拟机的，如VirtualBox、VMware、AWS等，主要好处是可以提供一个可配置、可移植和复用的软件环境，可以使用shell、chef、puppet等工具部署。所以vagrant不能单独使用，如果你用它来管理自己的开发环境的话，必须在自己的电脑里安装了虚拟机软件，我使用的是virtualbox。</p>
<p>Vagrant提供一个命令行工具vagrant，通过这个命令行工具可以直接启动一个虚拟机，当然你需要提前定义一个Vagrantfile文件，这有点类似Dockerfile之于docker了。</p>
<p>跟docker类比这来看vagrant就比较好理解了，vagrant也是用来提供一致性环境的，vagrant本身也提供一个镜像源，使用vagrant init hashicorp/precise64就可以初始化一个Ubuntu 12.04的镜像。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Vagrant是用来管理虚拟机的，如VirtualBox、VMware、AWS等，主要好处是可以提供一个可配置、可移植和复用的软件环境，可以使用shell、chef、puppet等工具部署。所以vagrant不能单独使用，如果你用它来管理自己的开发环境的话，必须在自己的电脑里安装了虚拟机软件，我使用的是virtualbox。</p>
<p>Vagrant提供一个命令行工具vagrant，通过这个命令行工具可以直接启动一个虚拟机，当然你需要提前定义一个Vagrantfile文件，这有点类似Dockerfile之于docker了。</p>
<p>跟docker类比这来看vagrant就比较好理解了，vagrant也是用来提供一致性环境的，vagrant本身也提供一个镜像源，使用vagrant init hashicorp/precise64就可以初始化一个Ubuntu 12.04的镜像。</p>
<!-- more -->
<h3 id="启动并运行">启动并运行</h3>
<pre><code>$ vagrant init hashicorp/precise64
$ vagrant up // 启动
</code></pre>
<p>先在目录生成一个Vagrantfile文件, 下载系统并启动。</p>
<h3 id="进入虚拟机">进入虚拟机</h3>
<p>vagrant up</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis - 过期删除策略]]></title>
        <id>https://caijh.github.io//post/redis-guo-qi-shan-chu-ce-lue</id>
        <link href="https://caijh.github.io//post/redis-guo-qi-shan-chu-ce-lue">
        </link>
        <updated>2019-07-15T03:18:31.000Z</updated>
        <summary type="html"><![CDATA[<p>Redis 采用的过期策略： 懒汉式删除 + 定期删除</p>
]]></summary>
        <content type="html"><![CDATA[<p>Redis 采用的过期策略： 懒汉式删除 + 定期删除</p>
<!-- more -->
<h1 id="三种过期删除策略">三种过期删除策略</h1>
<h2 id="定时删除">定时删除</h2>
<p>设置key的过期时间的同时为key设置一个定时器，在key过期时对key进行删除。<br>
优点： 保证内存被尽快回收。<br>
缺点：</p>
<ol>
<li>若key过多，删除key占用CPU时间</li>
<li>定时器的创建耗时，若对每个key创建定时器，会有大量定时器产生，影响性能</li>
</ol>
<h2 id="懒汉式删除">懒汉式删除</h2>
<p>在访问key的时候，判断key是否过期，如过期，删除key.<br>
优点： 删除操作只发生个获取key的时候，对CPU占用少<br>
缺点：若大量key超时，但很长一段时间内都没有访问，那些key会一直占用内存，可能会有内存泄漏</p>
<h2 id="定期删除">定期删除</h2>
<p>每隔一段时间执行一次删除过期key<br>
优点：</p>
<ol>
<li>减少对CPU的占用</li>
<li>克服懒汉式删除的缺点<br>
缺点：获取的key可以已经是过期的</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL - explain详解]]></title>
        <id>https://caijh.github.io//post/mysql-explain-xiang-jie</id>
        <link href="https://caijh.github.io//post/mysql-explain-xiang-jie">
        </link>
        <updated>2019-07-14T15:23:40.000Z</updated>
        <content type="html"><![CDATA[<h5 id="explain详解">Explain详解</h5>
<ol>
<li>
<p>ID列</p>
<p>ID值不同时, 执行计划由ID大的向ID小读; ID值相同时, 执行计划由上到下读</p>
</li>
<li>
<p>SELECT_TYPE列</p>
<table>
<thead>
<tr>
<th>值</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIMPLE</td>
<td style="text-align:left">不包含子查询或UNION操作的查询</td>
</tr>
<tr>
<td>PRIMARY</td>
<td style="text-align:left">查询中如果包含了子查询,那么最外层的查询会被标为primary</td>
</tr>
<tr>
<td>SUBQUERY</td>
<td style="text-align:left">select列表中的子查询</td>
</tr>
<tr>
<td>dependent subquery</td>
<td style="text-align:left">依赖外部结果的子查询</td>
</tr>
<tr>
<td>Union</td>
<td style="text-align:left">Union操作的第二个表之后的查询值为union</td>
</tr>
<tr>
<td>Dependent union</td>
<td style="text-align:left">当union作为子查询, 第二或第二个后的查询select_type</td>
</tr>
<tr>
<td>Union result</td>
<td style="text-align:left">union产生的结果集</td>
</tr>
<tr>
<td>Derived</td>
<td style="text-align:left">出现在from子句中的子查询</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>table列</p>
<p>表的名称或者表的别名.</p>
<p>unionM,N 由ID为M,N查询union产生的结果集</p>
<p>derivedN or subqueryN 表示由ID为N的查询产生结果集</p>
</li>
<li>
<p>partition列</p>
<p>对于分区表, 显示查询的分区id; 非分区表显示NULL</p>
</li>
<li>
<p>Type列</p>
<p>查询中使用了联结的类型</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>System</td>
<td>这是const联接类型中的一个特例, 当查询的表中只在一行显示</td>
</tr>
<tr>
<td>const</td>
<td>表中有且只有一个匹配的行时使用, 如主键或者唯一索引的查询</td>
</tr>
<tr>
<td>eq_ref</td>
<td>唯一索引或主键查找, 对于每个索引键, 表中只有一条记录与之匹配</td>
</tr>
<tr>
<td>ref</td>
<td>非唯一索引查找, 返回匹配某个单独值的所有行</td>
</tr>
<tr>
<td>ref_or_null</td>
<td>类似于ref类型的查询, 但是附加了对NULL值列的查询</td>
</tr>
<tr>
<td>index_merge</td>
<td>表示使用了索引合并</td>
</tr>
<tr>
<td>range</td>
<td>索引范围</td>
</tr>
<tr>
<td>index</td>
<td>Full index Scan全索引扫描,</td>
</tr>
<tr>
<td>all</td>
<td>全表扫描</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Extra列</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Distinct</td>
<td>优化distinct操作, 找到第一匹配的元组后暂停找同样值的动作</td>
</tr>
<tr>
<td>Not Exists</td>
<td>使用Not Exists来优化查询</td>
</tr>
<tr>
<td>Using filesort</td>
<td>使用额外操作进行排序</td>
</tr>
<tr>
<td>Using index</td>
<td>使用了覆盖索引进行查询</td>
</tr>
<tr>
<td>Using temporary</td>
<td>需要使用临时表处理查询</td>
</tr>
<tr>
<td>Using where</td>
<td>需要在服务层使用where条件过滤</td>
</tr>
<tr>
<td>select tables optimized away</td>
<td>直接通过索引来获得数据, 不用访问表</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>possible_keys 列</p>
<p>指出MySQL能使用哪些索引来优化查询, 查询列所涉及的列上的索引都会被列出, 但不一定会被使用.</p>
</li>
<li>
<p>Key列</p>
<p>查询优化器优化查询实际所使用索引列</p>
</li>
<li>
<p>Key_len列</p>
<p>表示索引字段的最大可能长度</p>
</li>
<li>
<p>ref列</p>
<p>表示哪些列或常量被用于查询索引列上的值</p>
</li>
<li>
<p>rows列</p>
<p>表示MySQL通过索引统计信息, 估算的需要读取的行数, 是一个统计抽样结果, 并不十分准确</p>
</li>
<li>
<p>filtered列</p>
<p>表示返回结果的行数占需要读取行数的百分比, 值越大越好</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[源码阅读 - AbstractQueuedSynchronizer]]></title>
        <id>https://caijh.github.io//post/yuan-dai-ma-abstractqueuedsynchronizer</id>
        <link href="https://caijh.github.io//post/yuan-dai-ma-abstractqueuedsynchronizer">
        </link>
        <updated>2019-07-14T10:38:40.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>AbstractQueuedSynchronizer, 简称AQS, 是Java 并发包的基础类，并发包中的很多api都是基于AQS来实现加锁与释放锁等功能。</p>
</blockquote>
<p>例如ReentrantLock内部拥有一个继承于AbstractQueuedSynchronizer的Sync类实现加锁与释放锁。<br>
AQS内部有一个state状态记录当前线程的加锁次数，还有一个exclusiveOwnerThread变量记录了独占的线程。</p>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>AbstractQueuedSynchronizer, 简称AQS, 是Java 并发包的基础类，并发包中的很多api都是基于AQS来实现加锁与释放锁等功能。</p>
</blockquote>
<p>例如ReentrantLock内部拥有一个继承于AbstractQueuedSynchronizer的Sync类实现加锁与释放锁。<br>
AQS内部有一个state状态记录当前线程的加锁次数，还有一个exclusiveOwnerThread变量记录了独占的线程。</p>
<!-- more -->
<pre><code>
    /**
     * Creates an instance of {@code ReentrantLock} with the
     * given fairness policy.
     *
     * @param fair {@code true} if this lock should use a fair ordering policy
     */
    public ReentrantLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
    }
</code></pre>
<p>ReentrantLock可以是公平的也可以不非公平的。</p>
<pre><code>/**
     * Acquires in exclusive mode, ignoring interrupts.  Implemented
     * by invoking at least once {@link #tryAcquire},
     * returning on success.  Otherwise the thread is queued, possibly
     * repeatedly blocking and unblocking, invoking {@link
     * #tryAcquire} until success.  This method can be used
     * to implement method {@link Lock#lock}.
     *
     * @param arg the acquire argument.  This value is conveyed to
     *        {@link #tryAcquire} but is otherwise uninterpreted and
     *        can represent anything you like.
     */
    public final void acquire(int arg) {
        if (!tryAcquire(arg) &amp;&amp;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
</code></pre>
<p>AQS中的加锁，申请不到锁，加入等待队列。</p>
<pre><code>/**
     * Sync object for fair locks
     */
    static final class FairSync extends Sync {
        private static final long serialVersionUID = -3000897897090466540L;
        /**
         * Fair version of tryAcquire.  Don't grant access unless
         * recursive call or no waiters or is first.
         */
        @ReservedStackAccess
        protected final boolean tryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                if (!hasQueuedPredecessors() &amp;&amp;
                    compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc &lt; 0)
                    throw new Error(&quot;Maximum lock count exceeded&quot;);
                setState(nextc);
                return true;
            }
            return false;
        }
    }
</code></pre>
<p>hasQueuedPredecessors看等待队列中是否有线程在排队。</p>
]]></content>
    </entry>
</feed>