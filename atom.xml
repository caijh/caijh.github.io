<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://caijh.github.io/</id>
    <title>John&apos;s Blog</title>
    <updated>2019-07-01T10:50:44.589Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://caijh.github.io/"/>
    <link rel="self" href="https://caijh.github.io//atom.xml"/>
    <subtitle>搬砖大佬</subtitle>
    <logo>https://caijh.github.io//images/avatar.png</logo>
    <icon>https://caijh.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, John&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[源码阅读-HashMap的实现原理]]></title>
        <id>https://caijh.github.io//post/yuan-ma-yue-du-hashmap-de-shi-xian-yuan-li</id>
        <link href="https://caijh.github.io//post/yuan-ma-yue-du-hashmap-de-shi-xian-yuan-li">
        </link>
        <updated>2019-07-01T09:38:57.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>原文链接：https://blog.csdn.net/fenglibing/article/details/91565912</p>
</blockquote>
<h3 id="hashmap的类图">HashMap的类图</h3>
<p><img src="https://caijh.github.io//post-images/1561974106214.png" alt=""></p>
<p>HashMap是Java开发当中使用得非常多的一种数据结构，因为其可以快速的定位到需要查找到数据，其最快的速度可以达到O(1)，最差的时候也可以达到O(n)。本文以Java8中的HashMap做为分析原型，因为不同的JDK版本中的HashMap，可能存在着底层实现上的不一样。</p>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>原文链接：https://blog.csdn.net/fenglibing/article/details/91565912</p>
</blockquote>
<h3 id="hashmap的类图">HashMap的类图</h3>
<p><img src="https://caijh.github.io//post-images/1561974106214.png" alt=""></p>
<p>HashMap是Java开发当中使用得非常多的一种数据结构，因为其可以快速的定位到需要查找到数据，其最快的速度可以达到O(1)，最差的时候也可以达到O(n)。本文以Java8中的HashMap做为分析原型，因为不同的JDK版本中的HashMap，可能存在着底层实现上的不一样。</p>
<!-- more -->
<p>HashMap是通过数组存储所有的数据，每个元素所存放数组的下标，是根据该存储元素的key的Hash值与该数组的长度减去1做与运算，如下所示：</p>
<pre><code>index = (length_of_array - 1) &amp; hash_of_the_key;
</code></pre>
<p>数组中存放元素的数据结构使用了Node和TreeNode两种数据结构，在单个Hash值对应的存储元素小于8个时，默认值为Node的单向链表形式存储，当单个Hash值存储的元素大于8个时，其会使用TreeNode的数据结构存储。</p>
<p>因为在单个Hash值对应的元素小于等于8个时，其查询时间最差为O(8)，但是当单个Hash值对应的元素大于8个时，再通过Node的单向链表的方式进行查询，速度上就会变得更慢了；这个时候HashMap就会将Node的普通节点转为TreeNode（红黑树）进行存储，这是由于TreeNode占用的空间大小约为常规节点的两倍，但是其查询速度可以得到保证，这个是通过空间换时间了。当TreeNode中包括的元素变得比较少时，为了存储空间的占用，也会转换为Node节点单向链表的方式实现，它们之间可以互相转换的。</p>
<h4 id="node">Node：</h4>
<pre><code>static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
        final int hash;
        final K key;
        V value;
        Node&lt;K,V&gt; next;

        Node(int hash, K key, V value, Node&lt;K,V&gt; next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }
        ......
}
</code></pre>
<p>可以看到每个Node中包括了4个属性，分别为：</p>
<pre><code>hash值：当前Node的Hash值
key：当前Node的key
value:当前Node的value
next:表示指向下一个Node的指针，相同hash值的Node，通过next进行遍历查找
</code></pre>
<h4 id="treenode">TreeNode：</h4>
<pre><code>static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {
        TreeNode&lt;K,V&gt; parent;  // red-black tree links
        TreeNode&lt;K,V&gt; left;
        TreeNode&lt;K,V&gt; right;
        TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion
        boolean red;
        TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) {
            super(hash, key, val, next);
        }
        ......
}
</code></pre>
<p>可以看到TreeNode使用的是红黑树（Red Black Tree）的数据结构，红黑树是一种自平衡二叉查找树，在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能，即使在最坏情况运行时间也是非常良好的，并且在实践中是非常高效的，它可以在O(log n)时间内做查找、插入和删除等操作，这里的n 是树中元素的数目。</p>
<p>以下是一张关于HashMap存储结构的示意图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5833578-bba5d27f64076c52?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h4 id="写入数据一切皆在注释中">写入数据（一切皆在注释中）</h4>
<p>其方法如下：</p>
<pre><code>//写入数据
public V put(K key, V value) {
	//首先根据hash方法，获取对应key的hash值，计算方法见后面
    return putVal(hash(key), key, value, false, true);
}

final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
	//判断用户存放元素的数组是否为空
    if ((tab = table) == null || (n = tab.length) == 0)
        //为空则进行初使化，并将初使化后的数组赋值给变量tab，数组的长值赋值给变量n
        n = (tab = resize()).length;
	//判断根据hash值与数组长度减1求与得到的下标，
	//从数组中获取元素并将其赋值给变量p(后续该变量p可以继续使用)，并判断该元素是否存在
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        //如果不存在则创建一个新的节点，并将其放到数组对应的下标中
        tab[i] = newNode(hash, key, value, null);
    else {//根据数组的下标取到了元素，并且该元素p且不为空，下面要判断p元素的类型是Node还是TreeNode
        Node&lt;K,V&gt; e; K k;
        //判断该数组对应下标取到的第一值是不是与正在存入值的hash值相同、
        //key相等（可能是对象，也可能是字符串），如果相等，则将取第一个值赋值给变量e
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            e = p;
        //判断取的对象是不是TreeNode，如果是则执行TreeNode的put方法
        else if (p instanceof TreeNode)
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        else {//是普通的Node节点，
        	//根据next属性对元素p执行单向链表的遍历
            for (int binCount = 0; ; ++binCount) {
                //如果被遍历的元素最后的next为空，表示后面没有节点了，则将新节点与当前节点的next属性建立关系
                if ((e = p.next) == null) {
                	//做为当前节点的后面的一个节点
                    p.next = newNode(hash, key, value, null);
                	//判断当前节点的单向链接的数量（8个）是不是已经达到了需要将其转换为TreeNode了
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        //如果是则将当前数组下标对应的元素转换为TreeNode
                        treeifyBin(tab, hash);
                    break;
                }
                //判断待插入的元素的hash值与key是否与单向链表中的某个元素的hash值与key是相同的，如果是则退出
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    break;
                p = e;
            }
        }
        //判断是否找到了与待插入元素的hash值与key值都相同的元素
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
        	//判断是否要将旧值替换为新值
            if (!onlyIfAbsent || oldValue == null)
                //满足于未指定不替换或旧值为空的情况，执行将旧值替换为新值
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    if (++size &gt; threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
</code></pre>
<p>Hash值的计算方法：</p>
<pre><code>// 计算指定key的hash值，原理是将key的hash code与hash code无符号向右移16位的值，执行异或运算。
// 在Java中整型为4个字节32位，无符号向右移16位，表示将高16位移到低16位上，然后再执行异或运行，也 
// 就是将hash code的高16位与低16位进行异或运行。
// 小于等于65535的数，其高16位全部都为0，因而将小于等于65535的值向右无符号移16位，则该数就变成了 
// 32位都是0，由于任何数与0进行异或都等于本身，因而hash code小于等于65535的key，其得到的hash值 
// 就等于其本身的hash code。
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}
</code></pre>
<h4 id="读取数据一切皆在注释中">读取数据（一切皆在注释中）</h4>
<pre><code>public V get(Object key) {
        Node&lt;K,V&gt; e;
        //根据Key获取元素
        if ((e = getNode(hash(key), key)) == null)
            return null;
        if (accessOrder)
            afterNodeAccess(e);
        return e.value;
    }

    final Node&lt;K,V&gt; getNode(int hash, Object key) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
        //if语句的第一个判断条件
        if ((tab = table) != null //将数组赋值给变量tab，将判断是否为null
            &amp;&amp; (n = tab.length) &gt; 0 //将数组的长值赋值给变量n
            &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) {//判断根据hash和数组长度减1的与运算，计算出来的的数组下标的第一个元素是不是为空
        	//判断第一个元素是否要找的元素，大部份情况下只要hash值太集中，或者元素不是很多，第一个元素往往都是需要的最终元素
            if (first.hash == hash &amp;&amp; // always check first node
                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
                //第一个元素就是要找的元素，因为hash值和key都相等，直接返回
                return first;
            if ((e = first.next) != null) {//如果第一元素不是要找到的元，则判断其next指向是否还有元素
                //有元素，判断其是否是TreeNode
                if (first instanceof TreeNode)
                	//是TreeNode则根据TreeNode的方式获取数据
                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
                do {//是Node单向链表，则通过next循环匹配，找到就退出，否则直到匹配完最后一个元素才退出
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        return e;
                } while ((e = e.next) != null);
            }
        }
        //没有找到则返回null
        return null;
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-桥接模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-qiao-jie-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-qiao-jie-mo-shi">
        </link>
        <updated>2019-06-30T13:04:34.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Decouple an abstraction from its implementation so that the two can vary independently.（将抽象和实现解耦，使得两者可以独立地变化。）</p>
</blockquote>
<h3 id="uml">UML</h3>
<p><img src="https://caijh.github.io//post-images/1561899948043.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Decouple an abstraction from its implementation so that the two can vary independently.（将抽象和实现解耦，使得两者可以独立地变化。）</p>
</blockquote>
<h3 id="uml">UML</h3>
<p><img src="https://caijh.github.io//post-images/1561899948043.png" alt=""></p>
<!-- more -->
<h3 id="代码实现">代码实现</h3>
<pre><code>public interface Implementor {
     //基本方法
     public void doSomething();
     public void doAnything();
}
public class ConcreteImplementor1 implements Implementor{
     public void doSomething(){
             //业务逻辑处理
     }
     public void doAnything(){
             //业务逻辑处理
     }
}
public class ConcreteImplementor2 implements Implementor{
     public void doSomething(){
             //业务逻辑处理
     }
     public void doAnything(){
             //业务逻辑处理
     }
}
public abstract class Abstraction {
     //定义对实现化角色的引用
     private Implementor imp;
     //约束子类必须实现该构造函数
     public Abstraction(Implementor _imp){
             this.imp = _imp;
     }
     //自身的行为和属性
     public void request(){
             this.imp.doSomething();
     }
     //获得实现化角色
     public Implementor getImp(){
             return imp;
     }
}
public class RefinedAbstraction extends Abstraction {
     //覆写构造函数
     public RefinedAbstraction(Implementor _imp){
             super(_imp);
     }
     //修正父类的行为
     @Override
     public void request(){
             /*
              * 业务处理...
              */
             super.request();
             super.getImp().doAnything();
     }
}
public class Client {
     public static void main(String[] args) {
             //定义一个实现化角色
             Implementor imp = new ConcreteImplementor1();
             //定义一个抽象化角色
             Abstraction abs = new RefinedAbstraction(imp);
             //执行行文
             abs.request();
     }
}
</code></pre>
<h4 id="桥梁模式的优点">桥梁模式的优点</h4>
<ul>
<li>抽象和实现分离
这也是桥梁模式的主要特点，它完全是为了解决继承的缺点而提出的设计模式。在该模式下，实现可以不受抽象的约束，不用再绑定在一个固定的抽象层次上。</li>
<li>优秀的扩充能力
看看我们的例子，想增加实现？没问题！想增加抽象，也没有问题！只要对外暴露的接口层允许这样的变化，我们已经把变化的可能性减到最小。</li>
<li>实现细节对客户透明
客户不用关心细节的实现，它已经由抽象层通过聚合关系完成了封装。</li>
</ul>
<h4 id="桥梁模式的使用场景">桥梁模式的使用场景</h4>
<ul>
<li>不希望或不适用使用继承的场景</li>
<li>接口或抽象类不稳定的场景</li>
<li>重用性要求较高的场景</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-享元模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-xiang-yuan-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-xiang-yuan-mo-shi">
        </link>
        <updated>2019-06-30T13:02:13.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Use sharing to support large numbers of fine-grained objects efficiently.（使用共享对象可有效地支持大量的细粒度的对象。）</p>
</blockquote>
<h3 id="uml">UML</h3>
<p><img src="https://caijh.github.io//post-images/1561899783648.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Use sharing to support large numbers of fine-grained objects efficiently.（使用共享对象可有效地支持大量的细粒度的对象。）</p>
</blockquote>
<h3 id="uml">UML</h3>
<p><img src="https://caijh.github.io//post-images/1561899783648.png" alt=""></p>
<!-- more -->
<h4 id="代码实现">代码实现</h4>
<pre><code>public abstract class Flyweight {
     //内部状态
     private String intrinsic;
     //外部状态
     protected final String Extrinsic;
     //要求享元角色必须接受外部状态
     public Flyweight(String _Extrinsic){
             this.Extrinsic = _Extrinsic;
     }
     //定义业务操作
     public abstract void operate();
     //内部状态的getter/setter
     public String getIntrinsic() {
             return intrinsic;
     }
     public void setIntrinsic(String intrinsic) {
             this.intrinsic = intrinsic;
     }
}
public class ConcreteFlyweight1 extends Flyweight{
     //接受外部状态
     public ConcreteFlyweight1(String _Extrinsic){
             super(_Extrinsic);
     }
     //根据外部状态进行逻辑处理
     public void operate(){
             //业务逻辑
     }
}
public class ConcreteFlyweight2 extends Flyweight{
     //接受外部状态
     public ConcreteFlyweight2(String _Extrinsic){
             super(_Extrinsic);
     }
     //根据外部状态进行逻辑处理
     public void operate(){
             //业务逻辑
     }
}
public class FlyweightFactory {
     //定义一个池容器
     private static  HashMap&lt;String,Flyweight&gt; pool= new HashMap&lt;String,Flyweight&gt;();
     //享元工厂
     public static Flyweight getFlyweight(String Extrinsic){
             //需要返回的对象
             Flyweight flyweight = null;
             //在池中没有该对象
             if(pool.containsKey(Extrinsic)){
                     flyweight = pool.get(Extrinsic);
             }else{
                     //根据外部状态创建享元对象
                     flyweight = new ConcreteFlyweight1(Extrinsic);
                     //放置到池中
                     pool.put(Extrinsic, flyweight);
             }
             return flyweight;
     }
}
</code></pre>
<h4 id="享元模式的优点与缺点">享元模式的优点与缺点</h4>
<p>享元模式是一个非常简单的模式，它可以大大减少应用程序创建的对象，降低程序内存的占用，增强程序的性能，但它同时也提高了系统复杂性，需要分离出外部状态和内部状态，而且外部状态具有固化特性，不应该随内部状态改变而改变，否则导致系统的逻辑混乱。</p>
<h4 id="享元模式的使用场景">享元模式的使用场景</h4>
<ul>
<li>系统中存在大量的相似对象。</li>
<li>细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。</li>
<li>需要缓冲池的场景。</li>
<li>应用不根据对象的identity</li>
</ul>
<h4 id="jdk中flyweight模式">JDK中Flyweight模式</h4>
<ul>
<li>java.lang.Integer#valueOf(int) (also on Boolean, Byte, Character, Short and Long)</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-解释器模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-jie-shi-qi-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-jie-shi-qi-mo-shi">
        </link>
        <updated>2019-06-30T13:00:34.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.（给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561899675724.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.（给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561899675724.png" alt=""></p>
<!-- more -->
<h4 id="代码实现">代码实现</h4>
<pre><code>public abstract class Expression {
     //每个表达式必须有一个解析任务
     public abstract Object interpreter(Context  ctx);
}
public class TerminalExpression extends Expression {
     //通常终结符表达式只有一个，但是有多个对象
     public Object interpreter(Context ctx) {
             return null;
     }
}
public class NonterminalExpression extends Expression {
     //每个非终结符表达式都会对其他表达式产生依赖
     public NonterminalExpression(Expression... expression){
     }
     
     public Object interpreter(Context ctx) {
             //进行文法处理
             return null;
     }
}
public class Client {
     public static void main(String[] args) {
          Context ctx = new Context();
          //通常定一个语法容器，容纳一个具体的表达式，通常为ListArray、LinkedList、Stack等类型
          Stack&lt;Expression&gt; stack = null; 
          for(;;){
               //进行语法判断，并产生递归调用
          }          
          //产生一个完整的语法树，由各个具体的语法分析进行解析
          Expression exp = stack.pop();
          //具体元素进入场景
          exp.interpreter(ctx);
     }
}
</code></pre>
<h4 id="jdk中解释模式">JDK中解释模式</h4>
<ul>
<li>java.util.Pattern</li>
<li>java.text.Normalizer</li>
<li>java.text.Format</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-状态模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-zhuang-tai-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-zhuang-tai-mo-shi">
        </link>
        <updated>2019-06-30T11:15:56.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Allow an object to alter its behavior when its internal state changes.The object will appear to change its class.（当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561893392766.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Allow an object to alter its behavior when its internal state changes.The object will appear to change its class.（当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561893392766.png" alt=""></p>
<!-- more -->
<h4 id="代码实现">代码实现</h4>
<pre><code>public abstract class State {
     //定义一个环境角色，提供子类访问
     protected Context context;
     //设置环境角色
     public void setContext(Context _context){
             this.context = _context;
     }
     //行为1
     public abstract void handle1();
     //行为2
     public abstract void handle2();
}
public class ConcreteState1 extends State {
     @Override
     public void handle1() {
             //本状态下必须处理的逻辑
     }
     @Override
     public void handle2() {
             //设置当前状态为stat2
             super.context.setCurrentState(Context.STATE2);
             //过渡到state2状态，由Context实现
             super.context.handle2();
     }
}
public class ConcreteState2 extends State {
     @Override
     public void handle1() {          
             //设置当前状态为state1
             super.context.setCurrentState(Context.STATE1);
             //过渡到state1状态，由Context实现
             super.context.handle1();
     }
     @Override
     public void handle2() {
             //本状态下必须处理的逻辑
     }
}
public class Context {
     //定义状态
     public final static State STATE1 = new ConcreteState1();
     public final static State STATE2 = new ConcreteState2();
     //当前状态
     private State CurrentState;
     //获得当前状态
     public State getCurrentState() {
             return CurrentState;
     }
     //设置当前状态
     public void setCurrentState(State currentState) {
             this.CurrentState = currentState;
             //切换状态
             this.CurrentState.setContext(this);
     }
     //行为委托
     public void handle1(){
             this.CurrentState.handle1();
     }
     public void handle2(){
             this.CurrentState.handle2();
     }
}
public class Client {
     public static void main(String[] args) {
             //定义环境角色
             Context context = new Context();
             //初始化状态
             context.setCurrentState(new ConcreteState1());
             //行为执行
             context.handle1();
             context.handle2();
     }
}
</code></pre>
<h4 id="状态模式的优点">状态模式的优点</h4>
<ul>
<li>结构清晰
避免了过多的switch...case或者if...else语句的使用，避免了程序的复杂性,提高系统的可维护性。</li>
<li>遵循设计原则
很好地体现了开闭原则和单一职责原则，每个状态都是一个子类，你要增加状态就要增加子类，你要修改状态，你只修改一个子类就可以了。</li>
<li>封装性非常好
这也是状态模式的基本要求，状态变换放置到类的内部来实现，外部的调用不用知道类内部如何实现状态和行为的变换。</li>
</ul>
<h4 id="状态模式的缺点">状态模式的缺点</h4>
<p>状态模式既然有优点，那当然有缺点了。但只有一个缺点，子类会太多，也就是类膨胀。如果一个事物有很多个状态也不稀奇，如果完全使用状态模式就会有太多的子类，不好管理，这个需要大家在项目中自己衡量。其实有很多方式可以解决这个状态问题，如在数据库中建立一个状态表，然后根据状态执行相应的操作，这个也不复杂，看大家的习惯和嗜好了。</p>
<h4 id="状态模式的使用场景">状态模式的使用场景</h4>
<ul>
<li>行为随状态改变而改变的场景
这也是状态模式的根本出发点，例如权限设计，人员的状态不同即使执行相同的行为结果也会不同，在这种情况下需要考虑使用状态模式。</li>
<li>条件、分支判断语句的替代者
在程序中大量使用switch语句或者if判断语句会导致程序结构不清晰，逻辑混乱，使用状态模式可以很好地避免这一问题，它通过扩展子类实现了条件的判断处理。</li>
</ul>
<h4 id="jdk中的状态模式">JDK中的状态模式</h4>
<ul>
<li>javax.faces.lifecycle.LifeCycle#execute()</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-访问者模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-fang-wen-zhe-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-fang-wen-zhe-mo-shi">
        </link>
        <updated>2019-06-30T11:07:37.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates. （封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561892912804.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates. （封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561892912804.png" alt=""></p>
<!-- more -->
<h4 id="代码实现">代码实现</h4>
<pre><code>public abstract class Element {
     //定义业务逻辑
     public abstract void doSomething();
     //允许谁来访问
     public abstract void accept(IVisitor visitor);
}
public class ConcreteElement1 extends Element{
     //完善业务逻辑
     public void doSomething(){
             //业务处理
     }
     //允许那个访问者访问
     public void accept(IVisitor visitor){
             visitor.visit(this);
     }
}
public class ConcreteElement2 extends Element{
     //完善业务逻辑
     public void doSomething(){
             //业务处理
     }
     //允许那个访问者访问
     public void accept(IVisitor visitor){
             visitor.visit(this);
     }
}
public interface IVisitor {
     //可以访问哪些对象
     public void visit(ConcreteElement1 el1);
     public void visit(ConcreteElement2 el2);
}
public class Visitor implements IVisitor {
     //访问el1元素
     public void visit(ConcreteElement1 el1) {
             el1.doSomething();
     }
     //访问el2元素
     public void visit(ConcreteElement2 el2) {
             el2.doSomething();
     }
}
public class ObjectStruture {
     //对象生成器，这里通过一个工厂方法模式模拟
     public static Element createElement(){
             Random rand = new Random();
             if(rand.nextInt(100) &gt; 50){
                     return new ConcreteElement1();
             }else{
                     return new ConcreteElement2();
             }
     }
}
public class Client {
     public static void main(String[] args) {
             for(int i=0;i&lt;10;i++){
                     //获得元素对象
                     Element el = ObjectStruture.createElement();
                     //接受访问者访问
                     el.accept(new Visitor());
             }          
     }
}
</code></pre>
<h4 id="访问者模式的优点">访问者模式的优点</h4>
<ul>
<li>符合单一职责原则
具体元素角色也就是Employee抽象类的两个子类负责数据的加载，而Visitor类则负责报表的展现，两个不同的职责非常明确地分离开来，各自演绎变化。</li>
<li>优秀的扩展性
由于职责分开，继续增加对数据的操作是非常快捷的，例如，现在要增加一份给大老板的报表，这份报表格式又有所不同，直接在Visitor中增加一个方法，传递数据后进行整理打印。</li>
<li>灵活性非常高</li>
</ul>
<h4 id="访问者模式的缺点">访问者模式的缺点</h4>
<ul>
<li>具体元素对访问者公布细节
访问者要访问一个类就必然要求这个类公布一些方法和数据，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的。</li>
<li>具体元素变更比较困难
具体元素角色的增加、删除、修改都是比较困难的，就上面那个例子，你想想，你要是想增加一个成员变量，如年龄age，Visitor就需要修改，如果Visitor是一个还好办，多个呢？业务逻辑再复杂点呢？
-- 违背了依赖倒置转原则
访问者依赖的是具体元素，而不是抽象元素，这破坏了依赖倒置原则，特别是在面向对象的编程中，抛弃了对接口的依赖，而直接依赖实现类，扩展比较难。</li>
</ul>
<h4 id="访问者模式的使用场景">访问者模式的使用场景</h4>
<ul>
<li>一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作，也就说是用迭代器模式已经不能胜任的情景。</li>
<li>需要对一个对象结构中的对象进行很多不同并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。</li>
</ul>
<h4 id="jdk中的访问者模式">JDK中的访问者模式</h4>
<ul>
<li>javax.lang.model.element.Element and javax.lang.model.element.ElementVisitor</li>
<li>javax.lang.model.type.TypeMirror and javax.lang.model.type.TypeVisitor</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-备忘录模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-bei-wang-lu-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-bei-wang-lu-mo-shi">
        </link>
        <updated>2019-06-30T10:43:33.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Without violating encapsulation,capture and externalize an object's internal state so that the object can be restored to this state later.（在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561891474684.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Without violating encapsulation,capture and externalize an object's internal state so that the object can be restored to this state later.（在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561891474684.png" alt=""></p>
<!-- more -->
<h4 id="代码实现">代码实现</h4>
<pre><code>/**
* Originator发起人角色
* 记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据。
*/
public class Originator {
     //内部状态
     private String state = &quot;&quot;;
     
     public String getState() {
             return state;
     }
     public void setState(String state) {
             this.state = state;
     }
     //创建一个备忘录
     public Memento createMemento(){
             return new Memento(this.state);
     }
     //恢复一个备忘录
     public void restoreMemento(Memento _memento){
             this.setState(_memento.getState());
     }
}
/**
* Memento备忘录角色
* 负责存储Originator发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。
*/
public class Memento {
     //发起人的内部状态
     private String state = &quot;&quot;;
     //构造函数传递参数
     public Memento(String _state){
             this.state = _state;
     }
     public String getState() {
             return state;
     }
     public void setState(String state) {
             this.state = state;
     }
}
/**
* Caretaker备忘录管理员角色
* 对备忘录进行管理、保存和提供备忘录。
*/
public class Caretaker {
     //备忘录对象
     private Memento memento;
     public Memento getMemento() {
             return memento;
     }
     public void setMemento(Memento memento) {
             this.memento = memento;
     }
}
public class Client {
     public static void main(String[] args) {
             //定义发起人
             Originator originator = new Originator();
             //定义出备忘录管理员
             Caretaker caretaker = new Caretaker();
             //创建一个备忘录
             caretaker.setMemento(originator.createMemento());
             //恢复一个备忘录
             originator.restoreMemento(caretaker.getMemento());
     }
}
</code></pre>
<h4 id="备忘录模式的使用场景">备忘录模式的使用场景</h4>
<ul>
<li>需要保存和恢复数据的相关状态场景。</li>
<li>提供一个可回滚（rollback）的操作；比如Word中的CTRL+Z组合键，IE浏览器中的后退按钮，文件管理器上的backspace键等。</li>
<li>需要监控的副本场景中。例如要监控一个对象的属性，但是监控又不应该作为系统的主业务来调用，它只是边缘应用，即使出现监控不准、错误报警也影响不大，因此一般的做法是备份一个主线程中的对象，然后由分析程序来分析。</li>
<li>数据库连接的事务管理就是用的备忘录模式，想想看，如果你要实现一个JDBC驱动，你怎么来实现事务？还不是用备忘录模式嘛！</li>
</ul>
<h4 id="jdk中的备忘录模式">JDK中的备忘录模式</h4>
<ul>
<li>java.util.Date</li>
<li>java.io.Serializable</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-门面模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-men-mian-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-men-mian-mo-shi">
        </link>
        <updated>2019-06-30T10:34:27.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Provide a unified interface to a set of interfaces in a subsystem.Facade defines a higher-level interface that makes the subsystem easier to use.（要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。）</p>
</blockquote>
<h4 id="uml图">UML图</h4>
<p><img src="https://caijh.github.io//post-images/1561890905550.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Provide a unified interface to a set of interfaces in a subsystem.Facade defines a higher-level interface that makes the subsystem easier to use.（要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。）</p>
</blockquote>
<h4 id="uml图">UML图</h4>
<p><img src="https://caijh.github.io//post-images/1561890905550.png" alt=""></p>
<!-- more -->
<h4 id="代码实现">代码实现</h4>
<pre><code>public class ClassA {
     public void doSomethingA(){
             //业务逻辑
     }
}
public class ClassB {
     
     public void doSomethingB(){
             //业务逻辑
     }
}
public class ClassC {
     
     public void doSomethingC(){
             //业务逻辑
     }
}
public class Facade {
     //被委托的对象
     private ClassA a = new ClassA();
     private ClassB b = new ClassB();
     private ClassC c = new ClassC();
     //提供给外部访问的方法
     public void methodA(){
             this.a.doSomethingA();
     }
     
     public void methodB(){
             this.b.doSomethingB();
     }
     
     public void methodC(){
             this.c.doSomethingC();
     }
}
</code></pre>
<h4 id="门面模式的优点">门面模式的优点</h4>
<ul>
<li>减少系统的相互依赖
想想看，如果我们不使用门面模式，外界访问直接深入到子系统内部，相互之间是一种强耦合关系，你死我就死，你活我才能活，这样的强依赖是系统设计所不能接受的，门面模式的出现就很好地解决了该问题，所有的依赖都是对门面对象的依赖，与子系统无关。</li>
<li>提高了灵活性
依赖减少了，灵活性自然提高了。不管子系统内部如何变化，只要不影响到门面对象，任你自由活动。</li>
<li>提高安全性
想让你访问子系统的哪些业务就开通哪些逻辑，不在门面上开通的方法，你休想访问到。</li>
</ul>
<h4 id="门面模式的缺点">门面模式的缺点</h4>
<p>门面模式最大的缺点就是不符合开闭原则，对修改关闭，对扩展开放，看看我们那个门面对象吧，它可是重中之重，一旦在系统投产后发现有一个小错误，你怎么解决？完全遵从开闭原则，根本没办法解决。继承？覆写？都顶不上用，唯一能做的一件事就是修改门面角色的代码，这个风险相当大，这就需要大家在设计的时候慎之又慎，多思考几遍才会有好收获。</p>
<h4 id="门面模式的使用场景">门面模式的使用场景</h4>
<ul>
<li>为一个复杂的模块或子系统提供一个供外界访问的接口</li>
<li>子系统相对独立——外界对子系统的访问只要黑箱操作即可</li>
<li>预防低水平人员带来的风险扩散</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-观察者模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-guan-cha-zhe-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-guan-cha-zhe-mo-shi">
        </link>
        <updated>2019-06-30T10:30:14.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Define a one-to-many dependency between objects so that when one object changes state,all its dependents are notified and updated automatically.（定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。）</p>
</blockquote>
<h3 id="uml">UML</h3>
<p><img src="https://caijh.github.io//post-images/1561890676877.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Define a one-to-many dependency between objects so that when one object changes state,all its dependents are notified and updated automatically.（定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。）</p>
</blockquote>
<h3 id="uml">UML</h3>
<p><img src="https://caijh.github.io//post-images/1561890676877.png" alt=""></p>
<!-- more -->
<h4 id="代码实现">代码实现</h4>
<pre><code>public abstract class Subject {
     //定义一个观察者数组
     private Vector&lt;Observer&gt; obsVector = new Vector&lt;Observer&gt;();
     //增加一个观察者
     public void addObserver(Observer o){
             this.obsVector.add(o);
     }
     //删除一个观察者
     public void delObserver(Observer o){
             this.obsVector.remove(o);
     }
     //通知所有观察者
     public void notifyObservers(){
             for(Observer o:this.obsVector){
                     o.update();
             }
     }
}
public class ConcreteSubject extends Subject {
     //具体的业务
     public void doSomething(){
             /*
              * do something
              */
             super.notifyObservers();
     }
}
public interface Observer {
     //更新方法
     public void update();
}
public class ConcreteObserver implements Observer {
     //实现更新方法
     public void update() {
             System.out.println(&quot;接收到信息，并进行处理！&quot;);
     }
}
public class Client {
     public static void main(String[] args) {
             //创建一个被观察者
             ConcreteSubject subject = new ConcreteSubject();
             //定义一个观察者
             Observer obs= new ConcreteObserver();
             //观察者观察被观察者
             subject.addObserver(obs);
             //观察者开始活动了
             subject.doSomething();
     }
}
</code></pre>
<h4 id="观察者模式的优点">观察者模式的优点</h4>
<ul>
<li>观察者和被观察者之间是抽象耦合
如此设计，则不管是增加观察者还是被观察者都非常容易扩展，而且在Java中都已经实现的抽象层级的定义，在系统扩展方面更是得心应手。</li>
<li>建立一套触发机制
根据单一职责原则，每个类的职责是单一的，那么怎么把各个单一的职责串联成真实世界的复杂的逻辑关系呢？比如，我们去打猎，打死了一只母鹿，母鹿有三个幼崽，因失去了母鹿而饿死，尸体又被两只秃鹰争抢，因分配不均，秃鹰开始斗殴，然后羸弱的秃鹰死掉，生存下来的秃鹰，则因此扩大了地盘……这就是一个触发机制，形成了一个触发链。观察者模式可以完美地实现这里的链条形式。</li>
</ul>
<h4 id="观察者模式的缺点">观察者模式的缺点</h4>
<p>观察者模式需要考虑一下开发效率和运行效率问题，一个被观察者，多个观察者，开发和调试就会比较复杂，而且在Java中消息的通知默认是顺序执行，一个观察者卡壳，会影响整体的执行效率。在这种情况下，一般考虑采用异步的方式。
多级触发时的效率更是让人担忧，大家在设计时注意考虑。</p>
<h4 id="观察者模式的使用场景">观察者模式的使用场景</h4>
<ul>
<li>关联行为场景。需要注意的是，关联行为是可拆分的，而不是“组合”关系。</li>
<li>事件多级触发场景。</li>
<li>跨系统的消息交换场景，如消息队列的处理机制。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-组合模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-zu-he-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-zu-he-mo-shi">
        </link>
        <updated>2019-06-30T10:05:20.000Z</updated>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Compose objects into tree structures to represent part-whole hierarchies.Composite lets clients treat individual objects and compositions of objects uniformly.（将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561889214924.png" alt=""></p>
<h4 id="代码实现">代码实现</h4>
<pre><code>public abstract class Component {
     //个体和整体都具有的共享
     public void doSomething(){
             //编写业务逻辑
     }
}
public class Composite extends Component {
     //构件容器
     private ArrayList&lt;Component&gt; componentArrayList = new ArrayList&lt;Component&gt;();
     //增加一个叶子构件或树枝构件
     public void add(Component component){
             this.componentArrayList.add(component);
     }
     //删除一个叶子构件或树枝构件
     public void remove(Component component){
             this.componentArrayList.remove(component);
     }
     //获得分支下的所有叶子构件和树枝构件
     public ArrayList&lt;Component&gt; getChildren(){
             return this.componentArrayList;
     }
}
public class Leaf extends Component {
     /*
      * 可以覆写父类方法
      * public void doSomething(){
      * 
      * }
      */
}
public class Client {
     public static void main(String[] args) {
            //创建一个根节点
             Composite root = new Composite();
             root.doSomething();
             //创建一个树枝构件
             Composite branch = new Composite();
             //创建一个叶子节点
             Leaf leaf = new Leaf();
             //建立整体
             root.add(branch);
             branch.add(leaf);          
     }
     //通过递归遍历树
     public static void display(Composite root){
             for(Component c:root.getChildren()){
                  if(c instanceof Leaf){ //叶子节点
                          c.doSomething();
                  }else{ //树枝节点
                          display((Composite)c);
                  }
             }
     }
}
</code></pre>
<h4 id="组合模式的优点">组合模式的优点</h4>
<ul>
<li>高层模块调用简单
一棵树形机构中的所有节点都是Component，局部和整体对调用者来说没有任何区别，也就是说，高层模块不必关心自己处理的是单个对象还是整个组合结构，简化了高层模块的代码。</li>
<li>节点自由增加
使用了组合模式后，我们可以看看，如果想增加一个树枝节点、树叶节点是不是都很容易，只要找到它的父节点就成，非常容易扩展，符合开闭原则，对以后的维护非常有利。</li>
</ul>
<h4 id="组合模式的缺点">组合模式的缺点</h4>
<p>组合模式有一个非常明显的缺点，看到我们在场景类中的定义，提到树叶和树枝使用时的定义了吗？直接使用了实现类！这在面向接口编程上是很不恰当的，与依赖倒置原则冲突，读者在使用的时候要考虑清楚，它限制了你接口的影响范围。</p>
<h4 id="组合模式使用场景">组合模式使用场景</h4>
<ul>
<li>想要表示对象间部分-整体的层次关系</li>
<li>想让客户端略过组合与个体的差异</li>
</ul>
]]></content>
    </entry>
</feed>