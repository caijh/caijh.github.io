<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://caijh.github.io/</id>
    <title>John&apos;s Blog</title>
    <updated>2019-06-24T15:08:23.835Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://caijh.github.io/"/>
    <link rel="self" href="https://caijh.github.io//atom.xml"/>
    <subtitle>搬砖大佬</subtitle>
    <logo>https://caijh.github.io//images/avatar.png</logo>
    <icon>https://caijh.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, John&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[设计模式-原型模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-yuan-xing-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-yuan-xing-mo-shi">
        </link>
        <updated>2019-06-24T15:06:00.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Specify the kinds of objects to create using a prototypical instance,and create new objects by copying this prototype.（用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561388832916.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Specify the kinds of objects to create using a prototypical instance,and create new objects by copying this prototype.（用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561388832916.png" alt=""></p>
<!-- more -->
<h4 id="代码实现">代码实现</h4>
<pre><code>public class PrototypeClass  implements Cloneable{
     //覆写父类Object方法
     @Override
     public PrototypeClass clone(){
             PrototypeClass prototypeClass = null;
             try {
                    prototypeClass = (PrototypeClass)super.clone();
             } catch (CloneNotSupportedException e) {
                    //异常处理
             }
             return prototypeClass;
     }
}
</code></pre>
<h4 id="原型模式的优点">原型模式的优点：</h4>
<ul>
<li>性能优良
原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。</li>
<li>逃避构造函数的约束
这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的。优点就是减少了约束，缺点也是减少了约束，需要大家在实际应用时考虑。</li>
</ul>
<h4 id="原型模式的使用场景">原型模式的使用场景</h4>
<ul>
<li>资源优化场景
类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。</li>
<li>性能和安全要求的场景
通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。</li>
<li>一个对象多个修改者的场景
一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。</li>
</ul>
<h4 id="jdk中的原型模式">JDK中的原型模式</h4>
<ul>
<li>java.lang.Object#clone()</li>
<li>java.lang.Cloneable</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-代理模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-dai-li-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-dai-li-mo-shi">
        </link>
        <updated>2019-06-24T15:03:20.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Provide a surrogate or placeholder for another object to control access to it.（为其他对象提供一种代理以控制对这个对象的访问。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561388635995.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Provide a surrogate or placeholder for another object to control access to it.（为其他对象提供一种代理以控制对这个对象的访问。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561388635995.png" alt=""></p>
<!-- more -->
<h4 id="代码实现">代码实现</h4>
<pre><code>public interface Subject {
     //定义一个方法
     public void request();
}
public class RealSubject implements Subject {
     //实现方法
     public void request() {
             //业务逻辑处理
     }
}
public class Proxy implements Subject {
     //要代理哪个实现类
     private Subject subject = null;    
     //默认被代理者
     public Proxy(){
             this.subject = new RealSubject();
     }
     //通过构造函数传递代理者
     public Proxy(Object...objects ){
     }
     //实现接口中定义的方法
     public void request() {
             this.before();
             this.subject.request();
             this.after();
     }
     //预处理
     private void before(){
             //do something
     }
     //善后处理
     private void after(){
             //do something
     }
}
</code></pre>
<h4 id="代理模式的优点">代理模式的优点</h4>
<ul>
<li>职责清晰
真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件事务，附带的结果就是编程简洁清晰。</li>
<li>职责清晰
真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件事务，附带的结果就是编程简洁清晰。</li>
<li>智能化</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-建造者模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-jian-zao-zhe-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-jian-zao-zhe-mo-shi">
        </link>
        <updated>2019-06-24T14:57:23.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Separate the construction of a complex object from its representation so that the same construction process can create different representations.（将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561388283844.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Separate the construction of a complex object from its representation so that the same construction process can create different representations.（将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561388283844.png" alt=""></p>
<!-- more -->
<h4 id="建造者模式的优点">建造者模式的优点</h4>
<ul>
<li>封装性
使用建造者模式可以使客户端不必知道产品内部组成的细节</li>
<li>建造者独立，容易扩展</li>
<li>便于控制细节风险
由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。</li>
</ul>
<h4 id="建造者模式使用场景">建造者模式使用场景</h4>
<ul>
<li>相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式。</li>
<li>多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时，则可以使用该模式。</li>
<li>产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式非常合适。</li>
<li>在对象创建过程中会使用到系统中的一些其他对象，这些对象在产品对象的创建过程中不易得到时，也可以采用建造者模式封装该对象的创建过程。该种场景只能是一个补偿方法，因为一个对象不容易获得，而在设计阶段竟然没有发觉，而要通过创建者模式柔化创建过程，本身已经违反设计的最初目标。</li>
</ul>
<h4 id="代码实现">代码实现</h4>
<pre><code>public class Product {
     public void doSomething(){
             //独立业务处理
     }
}
public abstract class Builder {    
     //设置产品的不同部分，以获得不同的产品
     public abstract void setPart();
     //建造产品
     public abstract Product buildProduct();
}
public class ConcreteBuilder extends Builder {
     private Product product = new Product();
     //设置产品零件
     public void setPart(){
             /*
              * 产品类内的逻辑处理
              */
     }  
     //组建一个产品
     public Product buildProduct() {
             return product;
     }
}
public class Director {
     private Builder builder = new ConcreteBuilder();
     //构建不同的产品
     public Product getAProduct(){
             builder.setPart();
             /*
              * 设置不同的零件，产生不同的产品
              */
             return builder.buildProduct();
     }
}
</code></pre>
<h4 id="jdk中的建造者模式">JDK中的建造者模式</h4>
<ul>
<li>java.lang.StringBuilder#append() (unsynchronized)</li>
<li>java.lang.StringBuilder#append() (unsynchronized)</li>
<li>java.nio.ByteBuffer#put()(alsoonCharBuffer,ShortBuffer,IntBuffer,LongBuffer,FloatBufferandDoubleBuffer)</li>
<li>javax.swing.GroupLayout.Group#addComponent()</li>
<li>All implementations of java.lang.Appendable</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-模板方法模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-mo-ban-fang-fa-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-mo-ban-fang-fa-mo-shi">
        </link>
        <updated>2019-06-24T14:48:26.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Define the skeleton of an algorithm in an operation,deferring some steps to subclasses.Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.（定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561387763499.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Define the skeleton of an algorithm in an operation,deferring some steps to subclasses.Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.（定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561387763499.png" alt=""></p>
<!-- more -->
<h4 id="代码实现">代码实现</h4>
<pre><code>public abstract class AbstractClass {
     //基本方法
     protected abstract void doSomething();
     //基本方法
     protected abstract void doAnything();
     //模板方法
     public void templateMethod(){
             /*
              * 调用基本方法，完成相关的逻辑
              */
             this.doAnything();
             this.doSomething();
     }
}
public class ConcreteClass1 extends AbstractClass {
     //实现基本方法
     protected void doAnything() {
             //业务逻辑处理
     }
     protected void doSomething() {
             //业务逻辑处理
     }
}
public class ConcreteClass2 extends AbstractClass {
     //实现基本方法
     protected void doAnything() {
             //业务逻辑处理
     }
     protected void doSomething() {
             //业务逻辑处理
     }
}
public class Client {
     public static void main(String[] args) {
             AbstractClass class1 = new ConcreteClass1();
             AbstractClass class2 = new ConcreteClass2();               
             //调用模板方法
             class1.templateMethod();
             class2.templateMethod();
     }
}
</code></pre>
<h4 id="模板方法模式的优点">模板方法模式的优点</h4>
<ul>
<li>封装不变部分，扩展可变部分
把认为是不变部分的算法封装到父类实现，而可变部分的则可以通过继承来继续扩展。</li>
<li>提取公共部分代码，便于维护
我们例子中刚刚走过的弯路就是最好的证明，如果我们不抽取到父类中，任由这种散乱的代码发生，想想后果是什么样子？维护人员为了修正一个缺陷，需要到处查找类似的代码！</li>
<li>行为由父类控制，子类实现
基本方法是由子类实现的，因此子类可以通过扩展的方式增加相应的功能，符合开闭原则。</li>
</ul>
<h4 id="模板方法模式的缺点">模板方法模式的缺点</h4>
<p>按照我们的设计习惯，抽象类负责声明最抽象、最一般的事物属性和方法，实现类完成具体的事物属性和方法。但是模板方法模式却颠倒了，抽象类定义了部分抽象方法，由子类实现，子类执行的结果影响了父类的结果，也就是子类对父类产生了影响，这在复杂的项目中，会带来代码阅读的难度，而且也会让新手产生不适感。</p>
<h4 id="模板方法的使用场景">模板方法的使用场景</h4>
<ul>
<li>多个子类有公有的方法，并且逻辑基本相同时。</li>
<li>重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。</li>
<li>重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数（见“模板方法模式的扩展”）约束其行为。</li>
</ul>
<h4 id="jdk中的模板方法模式">JDK中的模板方法模式</h4>
<ul>
<li>java.util.Collections#sort()</li>
<li>java.io.InputStream#skip()</li>
<li>java.io.InputStream#read()</li>
<li>java.util.AbstractList#indexOf()</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-抽象工厂模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-chou-xiang-gong-han-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-chou-xiang-gong-han-mo-shi">
        </link>
        <updated>2019-06-24T14:42:05.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Provide an interface for creating families of related or dependent objects without specifying their concrete classes.（为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。）</p>
</blockquote>
<h4 id="uml类图">UML类图</h4>
<p><img src="https://caijh.github.io//post-images/1561387400624.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Provide an interface for creating families of related or dependent objects without specifying their concrete classes.（为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。）</p>
</blockquote>
<h4 id="uml类图">UML类图</h4>
<p><img src="https://caijh.github.io//post-images/1561387400624.png" alt=""></p>
<!-- more -->
<h4 id="抽象工厂模式的优点">抽象工厂模式的优点：</h4>
<ul>
<li>封装性，每个产品的实现类不是高层模块要关心的，它要关心的是什么？是接口，是抽象，它不关心对象是如何创建出来，这由谁负责呢？工厂类，只要知道工厂类是谁，我就能创建出一个需要的对象，省时省力，优秀设计就应该如此。</li>
<li>产品族内的约束为非公开状态。</li>
</ul>
<h4 id="抽象工厂模式的缺点">抽象工厂模式的缺点：</h4>
<p>抽象工厂模式的最大缺点就是产品族扩展非常困难，为什么这么说呢？我们以通用代码为例，如果要增加一个产品C，也就是说产品家族由原来的2个增加到3个，看看我们的程序有多大改动吧！抽象类AbstractCreator要增加一个方法createProductC()，然后两个实现类都要修改，想想看，这严重违反了开闭原则，而且我们一直说明抽象类和接口是一个契约。改变契约，所有与契约有关系的代码都要修改，那么这段代码叫什么？叫“有毒代码”，——只要与这段代码有关系，就可能产生侵害的危险！</p>
<h4 id="jdk中的抽象工厂模式">JDK中的抽象工厂模式</h4>
<ul>
<li>java.util.Calendar#getInstance()</li>
<li>java.util.Arrays#asList()</li>
<li>java.util.ResourceBundle#getBundle()</li>
<li>java.sql.DriverManager#getConnection()</li>
<li>java.sql.Connection#createStatement()</li>
<li>java.sql.Statement#executeQuery()</li>
<li>java.text.NumberFormat#getInstance()</li>
<li>javax.xml.transform.TransformerFactory#newInstance()</li>
</ul>
<h4 id="代码实现">代码实现</h4>
<pre><code>public abstract class AbstractCreator {
     //创建A产品家族
     public abstract AbstractProductA createProductA(); 
     //创建B产品家族
     public abstract AbstractProductB createProductB();
}

public class Creator1 extends AbstractCreator {    
     //只生产产品等级为1的A产品
     public AbstractProductA createProductA() { 
             return new ProductA1();
     }
     //只生产产品等级为1的B产品
     public AbstractProductB createProductB() {
             return new ProductB1();
     }
}
public class Creator2 extends AbstractCreator {    
     //只生产产品等级为2的A产品
     public AbstractProductA createProductA() { 
             return new ProductA2();
     }
     //只生产产品等级为2的B产品
     public AbstractProductB createProductB() {
             return new ProductB2();
     }
}

public class Client {
     public static void main(String[] args) {
             //定义出两个工厂
             AbstractCreator creator1 = new Creator1();
             AbstractCreator creator2 = new Creator2();
             //产生A1对象
             AbstractProductA a1 =  creator1.createProductA();
             //产生A2对象
             AbstractProductA a2 = creator2.createProductA();
             //产生B1对象
             AbstractProductB b1 = creator1.createProductB();
             //产生B2对象
             AbstractProductB b2 = creator2.createProductB();
             /*
              * 然后在这里就可以为所欲为了...
              */
     }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-工厂方法模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-gong-han-fang-fa-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-gong-han-fang-fa-mo-shi">
        </link>
        <updated>2019-06-24T10:38:35.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Define an interface for creating an object,but let subclasses decide which class to instantiate.Factory Method lets a class defer instantiation to subclasses.（定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/FactoryMethod.jpg" alt="IMAGE"></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Define an interface for creating an object,but let subclasses decide which class to instantiate.Factory Method lets a class defer instantiation to subclasses.（定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/FactoryMethod.jpg" alt="IMAGE"></p>
<!-- more -->
<h4 id="工厂方法模式的优点">工厂方法模式的优点</h4>
<ul>
<li>首先，良好的封装性，代码结构清晰。一个对象创建是有条件约束的，如一个调用者需要一个具体的产品对象，只要知道这个产品的类名（或约束字符串）就可以了，不用知道创建对象的艰辛过程，降低模块间的耦合。</li>
<li>再次，屏蔽产品类。这一特点非常重要，产品类的实现如何变化，调用者都不需要关心，它只需要关心产品的接口，只要接口保持不变，系统中的上层模块就不要发生变化。</li>
<li>最后，工厂方法模式是典型的解耦框架。高层模块值需要知道产品的抽象类，其他的实现类都不用关心，符合迪米特法则，我不需要的就不要去交流；也符合依赖倒置原则，只依赖产品类的抽象；当然也符合里氏替换原则，使用产品子类替换产品父类，没问题！</li>
</ul>
<h4 id="工厂方法模式的使用场景">工厂方法模式的使用场景</h4>
<ul>
<li>工厂方法模式是new一个对象的替代品，所以在所有需要生成对象的地方都可以使用，但是需要慎重地考虑是否要增加一个工厂类进行管理，增加代码的复杂度。</li>
<li>需要灵活的、可扩展的框架时，可以考虑采用工厂方法模式。</li>
<li>工厂方法模式可以用在异构项目中</li>
<li>可以使用在测试驱动开发的框架下</li>
</ul>
<h4 id="jdk中的工厂方法模式">JDK中的工厂方法模式</h4>
<ul>
<li>java.util.Calendar#getInstance()</li>
<li>java.util.ResourceBundle#getBundle()</li>
<li>java.text.NumberFormat#getInstance()</li>
<li>java.nio.charset.Charset#forName()</li>
<li>java.net.URLStreamHandlerFactory#createURLStreamHandler(String) (Returns singleton object per protocol)</li>
</ul>
<h4 id="工厂方法模式代码">工厂方法模式代码</h4>
<pre><code>public abstract class Product {    
     //产品类的公共方法
     public void method1(){
             //业务逻辑处理
     }  
     //抽象方法
     public abstract void method2();    
}

public class ConcreteProduct1 extends Product {
     public void method2() {
             //业务逻辑处理
     }
}
public class ConcreteProduct2 extends Product {
     public void method2() {
             //业务逻辑处理
     }
}

public abstract class Creator {    
     /*
      * 创建一个产品对象，其输入参数类型可以自行设置
      * 通常为String、Enum、Class等，当然也可以为空
      */        
     public abstract &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; c);
}

public class ConcreteCreator extends Creator {     
     public &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; c){
             Product product=null;
             try {
                    product = (Product)Class.forName(c.getName()).newInstance();
             } catch (Exception e) {
                    //异常处理
             }
             return (T)product;         
     }
}

public class ConcreteCreator extends Creator {     
     public &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; c){
             Product product=null;
             try {
                    product = (Product)Class.forName(c.getName()).newInstance();
             } catch (Exception e) {
                    //异常处理
             }
             return (T)product;         
     }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-单例模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-dan-li-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-dan-li-mo-shi">
        </link>
        <updated>2019-06-24T09:59:12.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>Ensure a class has only one instance, and provide a global point of access to it.（确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。）</p>
</blockquote>
<h5 id="类图">类图</h5>
<p><img src="https://caijh.github.io//post-images/1561372464381.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>Ensure a class has only one instance, and provide a global point of access to it.（确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。）</p>
</blockquote>
<h5 id="类图">类图</h5>
<p><img src="https://caijh.github.io//post-images/1561372464381.png" alt=""></p>
<!-- more -->
<h6 id="饿汉模式">饿汉模式</h6>
<pre><code>public class Singleton {

    private static final Singleton SINGLETON = new Singleton();

    private Singleton() {

    }

    public static Singleton getInstance() {
        return SINGLETON;
    }
}
</code></pre>
<h6 id="懒汉模式">懒汉模式</h6>
<pre><code>public class SingletonLay {
    private static SingletonLay singletonLay = null;

    private SingletonLay() {

    }

    public static SingletonLay getSingletonLay() {
        if (singletonLay == null) {
            synchronized (SingletonLay.class) {
                if (singletonLay == null) {
                    singletonLay = new SingletonLay();
                }
            }
        }
        return singletonLay;
    }
}
</code></pre>
<p><strong>隐患</strong>
上述写法看似解决了问题，但是有个很大的隐患。实例化对象的那行代码（标记为error的那行），实际上可以分解成以下三个步骤：</p>
<ol>
<li>
<p>分配内存空间</p>
</li>
<li>
<p>初始化对象</p>
</li>
<li>
<p>将对象指向刚分配的内存空间
但是有些编译器为了性能的原因，可能会将第二步和第三步进行重排序，顺序就成了：</p>
</li>
<li>
<p>分配内存空间</p>
</li>
<li>
<p>将对象指向刚分配的内存空间</p>
</li>
<li>
<p>初始化对象</p>
</li>
</ol>
<p>正确的双重检查锁</p>
<pre><code>public class SingletonLay {
    private static volilate SingletonLay singletonLay = null;

    private SingletonLay() {

    }

    public static SingletonLay getSingletonLay() {
        if (singletonLay == null) {
            synchronized (SingletonLay.class) {
                if (singletonLay == null) {
                    singletonLay = new SingletonLay();
                }
            }
        }
        return singletonLay;
    }
}
</code></pre>
<h6 id="enum-方式">Enum 方式</h6>
<pre><code>class Resource{
}

public enum Singleton {
    INSTANCE;
    private Resource instance;
    Singleton() {
        instance = new Resource();
    }
    public Resource getInstance() {
        return instance;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-SOLID原则]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-solid-yuan-ze</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-solid-yuan-ze">
        </link>
        <updated>2019-06-24T09:43:42.000Z</updated>
        <summary type="html"><![CDATA[<p>运用设计模式，需要记住六大设计原则：</p>
<ul>
<li>Single Responsibility Principle：单一职责原则</li>
<li>Open Closed Principle：开闭原则</li>
<li>Liskov Substitution Principle：里氏替换原则</li>
<li>Law of Demeter：迪米特法则</li>
<li>Interface Segregation Principle：接口隔离原则</li>
<li>Dependence Inversion Principle：依赖倒置原则</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<p>运用设计模式，需要记住六大设计原则：</p>
<ul>
<li>Single Responsibility Principle：单一职责原则</li>
<li>Open Closed Principle：开闭原则</li>
<li>Liskov Substitution Principle：里氏替换原则</li>
<li>Law of Demeter：迪米特法则</li>
<li>Interface Segregation Principle：接口隔离原则</li>
<li>Dependence Inversion Principle：依赖倒置原则</li>
</ul>
<!-- more -->
<h3 id="单一职责原则">单一职责原则</h3>
<blockquote>
<p>There should never be more than one reason for a class to change.
引起类的变更原因只有一个，类或接口只负责做一件事。
单一职责原则的好处：</p>
</blockquote>
<ul>
<li>类的复杂性降低，实现什么职责都有清晰明确的定义；</li>
<li>可读性提高，复杂性降低，那当然可读性提高了；</li>
<li>可维护性提高，可读性提高，那当然更容易维护了；
变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。
对于接口，我们在设计的时候一定要做到单一，但是对于实现类就需要多方面考虑了。生搬硬套单一职责原则会引起类的剧增，给维护带来非常多的麻烦，而且过分细分类的职责也会人为地增加系统的复杂性。本来一个类可以实现的行为硬要拆成两个类，然后再使用聚合或组合的方式耦合在一起，人为制造了系统的复杂性。</li>
</ul>
<h3 id="开闭原则">开闭原则</h3>
<blockquote>
<p>Software entities like classes,modules and functions should be open for extension but closed for modifications.（一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。）
开闭原则对扩展开放，对修改关闭，并不意味着不做任何修改，低层模块的变更，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段。</p>
</blockquote>
<h4 id="为什么要使用开闭原则">为什么要使用开闭原则？</h4>
<p>开闭原则对测试的影响
开闭原则可以提高复用性
开闭原则可以提高可维护性
开闭原则可以提高可维护性</p>
<h4 id="如何使用开闭原则">如何使用开闭原则？</h4>
<ul>
<li>抽象约束</li>
<li>元数据控制模块行为</li>
<li>制定项目章程，约定优于配置</li>
<li>封装变化，将相同的变化封装到一个接口或抽象类中</li>
</ul>
<h3 id="里氏替换原则">里氏替换原则</h3>
<blockquote>
<p>Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象。）</p>
</blockquote>
<h3 id="迪米特法则">迪米特法则</h3>
<blockquote>
<p>一个对象应该对其他对象有最少的了解。</p>
</blockquote>
<h3 id="接口隔离原则">接口隔离原则</h3>
<blockquote>
<p>Clients should not be forced to depend upon interfaces that they don't use.（客户端不应该依赖它不需要的接口。）
The dependency of one class to another one should depend on the smallest possible interface.（类间的依赖关系应该建立在最小的接口上。）</p>
</blockquote>
<h3 id="依赖倒置原则">依赖倒置原则</h3>
<p>High level modules should not depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions.
翻译过来，包含三层含义：</p>
<ul>
<li>高层模块不应该依赖低层模块，两者都应该依赖其抽象；</li>
<li>抽象不应该依赖细节；</li>
<li>细节应该依赖抽象。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL规范]]></title>
        <id>https://caijh.github.io//post/mysql-gui-fan</id>
        <link href="https://caijh.github.io//post/mysql-gui-fan">
        </link>
        <updated>2019-06-24T02:54:06.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="数据库命名规范">数据库命名规范</h1>
<ul>
<li>所有数据库对象名称必须使用小写字母并用下划线分割</li>
<li>所有数据库对象名称禁止使用mysql保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）</li>
<li>数据库对象的命名要能做到见名识意，并且最后不要超过32个字符</li>
<li>临时库表必须以tmp_为前缀并以日期为后缀，备份表必须以bak_为前缀并以日期(时间戳)为后缀</li>
<li>所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1 id="数据库命名规范">数据库命名规范</h1>
<ul>
<li>所有数据库对象名称必须使用小写字母并用下划线分割</li>
<li>所有数据库对象名称禁止使用mysql保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）</li>
<li>数据库对象的命名要能做到见名识意，并且最后不要超过32个字符</li>
<li>临时库表必须以tmp_为前缀并以日期为后缀，备份表必须以bak_为前缀并以日期(时间戳)为后缀</li>
<li>所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）</li>
</ul>
<!-- more -->
<h1 id="数据库基本设计规范">数据库基本设计规范</h1>
<ol>
<li>
<p>所有表必须使用Innodb存储引擎
没有特殊要求（即Innodb无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用Innodb存储引擎（mysql5.5之前默认使用Myisam，5.6以后默认的为Innodb）Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好</p>
</li>
<li>
<p>数据库和表的字符集统一使用UTF8
兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效</p>
</li>
<li>
<p>所有表与字段都要添加注释
使用comment从句添加表和列的备注 从一开始就进行数据字典的维护</p>
</li>
<li>
<p>尽量控制单表数据量的大小，建议控制在500万以内
500万并不是MySQL数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题
可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p>
</li>
<li>
<p>谨慎使用MySQL分区表
分区表在物理上表现为多个文件，在逻辑上表现为一个表 谨慎选择分区键，跨分区查询效率可能更低 建议采用物理分表的方式管理大数据</p>
</li>
<li>
<p>尽量做到冷热数据分离，减小表的宽度
MySQL限制每个表最多存储4096列，并且每一行数据的大小不能超过65535字节 减少磁盘IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的IO） 更有效的利用缓存，避免读入无用的冷数据 经常一起使用的列放到一个表中（避免更多的关联操作）</p>
</li>
<li>
<p>禁止在表中建立预留字段</p>
</li>
<li>
<p>禁止在数据库中存储图片，文件等大的二进制数据
通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时 通常存储于文件服务器，数据库只存储文件地址信息</p>
</li>
<li>
<p>禁止在线上做数据库压力测试</p>
</li>
<li>
<p>禁止从开发环境，测试环境直接连接生成环境数据库</p>
</li>
</ol>
<h1 id="数据库字段设计规范">数据库字段设计规范</h1>
<ol>
<li>优先选择符合存储需要的最小的数据类型
列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的IO次数也就越多， 索引的性能也就越差
1）将字符串转换成数字类型存储，如：将IP地址转换成整形数据
2）对于非负型的数据（如自增ID、整型IP）来说，要优先使用无符号整型来存储</li>
<li>避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据
建议把BLOB或是TEXT列分离到单独的扩展表中
Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。
而且对于这种数据，Mysql还是要进行二次查询，会使sql性能变得很差，但是不是说一定不能使用这样的数据类型。
如果一定要使用，建议把BLOB或是TEXT列分离到单独的扩展表中，查询时一定不要使用select * 而只需要取出必要的列，不需要TEXT列的数据时不要对该列进行查询。
TEXT或BLOB类型只能使用前缀索引，因为MySQL对索引字段长度是有限制的，所以TEXT类型只能使用前缀索引，并且TEXT列上是不能有默认值的。</li>
<li>避免使用ENUM类型</li>
<li>尽可能把所有列定义为NOT NULL
原因：</li>
</ol>
<ul>
<li>索引NULL列需要额外的空间来保存，所以要占用更多的空间</li>
<li>进行比较和计算时要对NULL值做特别的处理</li>
</ul>
<ol start="5">
<li>使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间</li>
<li>同财务相关的金额类数据必须使用decimal类型
Decimal类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每4个字节可以存储9位数字，并且小数点要占用一个字节。可用于存储比bigint更大的整型数据。</li>
</ol>
<h1 id="索引设计规范">索引设计规范</h1>
<ol>
<li>限制每张表上的索引数量，建议单张表索引不超过5个
索引并不是越多越好！索引可以提高效率同样可以降低效率。
索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。
因为mysql优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加mysql优化器生成执行计划的时间，同样会降低查询性能。</li>
<li>禁止给表中的每一列都建立单独的索引
5.6版本之前，一个sql只能使用到一个表中的一个索引，5.6以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好</li>
<li>每个Innodb表必须有个主键
Innodb是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。
每个表都可以有多个索引，但是表的存储顺序只能有一种 Innodb是按照主键索引的顺序来组织表的。
不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引） 不要使用UUID、MD5、HASH、字符串列作为主键（无法保证数据的顺序增长）。
主键建议使用自增ID值。</li>
</ol>
<h1 id="常见索引列建议">常见索引列建议</h1>
<ul>
<li>出现在SELECT、UPDATE、DELETE语句的WHERE从句中的列</li>
<li>包含在ORDER BY、GROUP BY、DISTINCT中的字段</li>
<li>多表join的关联列</li>
</ul>
<h1 id="如何选择索引列的顺序">如何选择索引列的顺序</h1>
<p>建立索引的目的是：希望通过索引进行数据查找，减少随机IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。</p>
<ul>
<li>区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）；</li>
<li>尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO性能也就越好）；</li>
<li>使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）。</li>
</ul>
<h1 id="避免建立冗余索引和重复索引">避免建立冗余索引和重复索引</h1>
<p>因为这样会增加查询优化器生成执行计划的时间。</p>
<ul>
<li>重复索引示例：primary key(id)、index(id)、unique index(id)</li>
<li>冗余索引示例：index(a,b,c)、index(a,b)、index(a)</li>
</ul>
<h1 id="优先考虑覆盖索引">优先考虑覆盖索引</h1>
<p>对于频繁的查询优先考虑使用覆盖索引。</p>
<p>覆盖索引：就是包含了所有查询字段(where,select,ordery by,group by包含的字段)的索引</p>
<p>覆盖索引的好处：</p>
<ul>
<li>避免Innodb表进行索引的二次查询</li>
</ul>
<p>Innodb是以聚集索引的顺序来存储的，对于Innodb来说，二级索引在叶子节点中所保存的是行的主键信息，
如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了IO操作，提升了查询效率。</p>
<ul>
<li>可以把随机IO变成顺序IO加快查询效率</li>
</ul>
<p>由于覆盖索引是按键值的顺序存储的，对于IO密集型的范围查找来说，对比随机从磁盘读取每一行的数据IO要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的IO转变成索引查找的顺序IO。</p>
<h1 id="索引set规范">索引SET规范</h1>
<p>尽量避免使用外键约束</p>
<p>不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引；
外键可用于保证数据的参照完整性，但建议在业务端实现；
外键会影响父表和子表的写操作从而降低性能。</p>
<h1 id="数据库sql开发规范">数据库SQL开发规范</h1>
<ol>
<li>建议使用预编译语句进行数据库操作
预编译语句可以重复使用这些计划，减少SQL编译所需要的时间，还可以解决动态SQL所带来的SQL注入的问题 只传参数，比传递SQL语句更高效 相同语句可以一次解析，多次使用，提高处理效率。</li>
<li>避免数据类型的隐式转换
隐式转换会导致索引失效。如：select name,phone from customer where id = '111';</li>
<li>充分利用表上已经存在的索引</li>
<li>数据库设计时，应该要对以后扩展进行考虑</li>
<li>程序连接不同的数据库使用不同的账号，禁止跨库查询</li>
<li>禁止使用SELECT * 必须使用SELECT &lt;字段列表&gt; 查询</li>
<li>禁止使用不含字段列表的INSERT语句</li>
<li>避免使用子查询，可以把子查询优化为join操作
通常子查询在in子句中，且子查询中为简单SQL(不包含union、group by、order by、limit从句)时，才可以把子查询转化为关联查询进行优化。
子查询性能差的原因：</li>
</ol>
<ul>
<li>子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响；</li>
<li>特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大；</li>
<li>由于子查询会产生大量的临时表也没有索引，所以会消耗过多的CPU和IO资源，产生大量的慢查询。</li>
</ul>
<ol start="9">
<li>避免使用JOIN关联太多的表
对于Mysql来说，是存在关联缓存的，缓存的大小可以由join_buffer_size参数进行设置。
在Mysql中，对于同一个SQL多关联（join）一个表，就会多分配一个关联缓存，如果在一个SQL中关联的表越多，所占用的内存也就越大。
如果程序中大量的使用了多表关联的操作，同时join_buffer_size设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。
同时对于关联操作来说，会产生临时表操作，影响查询效率Mysql最多允许关联61个表，建议不超过5个。</li>
<li>减少同数据库的交互次数</li>
<li>对应同一列进行or判断时，使用in代替or</li>
<li>禁止使用order by rand() 进行随机排序
会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的CPU和IO及内存资源。</li>
<li>WHERE从句中禁止对列进行函数转换和计算
对列进行函数转换或计算时会导致无法使用索引。</li>
<li>拆分复杂的大SQL为多个小SQL</li>
</ol>
<h1 id="数据库操作行为规范">数据库操作行为规范</h1>
<ol>
<li>超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作</li>
<li>对于大表使用pt-online-schema-change修改表结构</li>
</ol>
<ul>
<li>避免大表修改产生的主从延迟</li>
<li>避免在对表字段进行修改时进行锁表</li>
</ul>
<ol start="3">
<li>禁止为程序使用的账号赋予super权限</li>
<li>对于程序连接数据库账号，遵循权限最小原则
程序使用数据库账号只能在一个DB下使用，不准跨库 程序使用的账号原则上不准有drop权限。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GraphQL学习笔记]]></title>
        <id>https://caijh.github.io//post/graphql-xue-xi-bi-ji</id>
        <link href="https://caijh.github.io//post/graphql-xue-xi-bi-ji">
        </link>
        <updated>2019-06-24T02:35:07.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="graphql是什么">GraphQL是什么？</h2>
<p>GraphQl官方的定义是：</p>
<p>GraphQL是一种API的查询语言。 它用于运行时完成数据查询。 GraphQL服务与传输无关，但通常通过HTTP提供。</p>
<p>GraphQl特性</p>
<ul>
<li>GraphQL query， 只请求需要的数据</li>
<li>GraphQL schema， 在服务器端定义了api的数据结构</li>
<li>可以在一个请求中获取多个数据，如果是rest的话， 需要访问多个接口</li>
</ul>
<p>与REST对比，REST的缺点的主要有以下:</p>
<ul>
<li>Overfetching 往往会给客户端返回过多的数据</li>
<li>endpoints过多，管理endpoints是个问题。Endpoints修改，客户端也需要修改。</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h2 id="graphql是什么">GraphQL是什么？</h2>
<p>GraphQl官方的定义是：</p>
<p>GraphQL是一种API的查询语言。 它用于运行时完成数据查询。 GraphQL服务与传输无关，但通常通过HTTP提供。</p>
<p>GraphQl特性</p>
<ul>
<li>GraphQL query， 只请求需要的数据</li>
<li>GraphQL schema， 在服务器端定义了api的数据结构</li>
<li>可以在一个请求中获取多个数据，如果是rest的话， 需要访问多个接口</li>
</ul>
<p>与REST对比，REST的缺点的主要有以下:</p>
<ul>
<li>Overfetching 往往会给客户端返回过多的数据</li>
<li>endpoints过多，管理endpoints是个问题。Endpoints修改，客户端也需要修改。</li>
</ul>
<!-- more -->
<p>GraphQL只是一种协议， 官方提供了多种实现。如java, javascript.</p>
<p>GraphQL中的类型</p>
<ul>
<li>
<p>scalar type</p>
<p>GraphQL的Scalar Type有Int, String, Float, Boolean, ID</p>
</li>
<li>
<p>object type</p>
</li>
<li>
<p>Fragments</p>
<pre><code class="language-java">fragment liftInfo on Lift {
  name
  status
  capacity
  night
  elevationGain
}
</code></pre>
<pre><code class="language-java">query {
    Lift(id: &quot;jazz-cat&quot;) {
      ...liftInfo
      trailAccess {
        name
        difficulty
      }
    }
    Trail(id: &quot;river-run&quot;) {
      name
      difficulty
      accessedByLifts {
        ...liftInfo
      }
    }
}
</code></pre>
<p>The fragment in this example is named <code>liftInfo</code>, and it is a selection set on the <code>Lift</code> type.</p>
</li>
<li>
<p>union type</p>
<pre><code class="language-java">union AgendaItem = StudyGroup | Workout

type StudyGroup {
    name: String!
    subject: String
    students: [User!]!
}

type Workout {
    name: String!
    reps: Int!
}

type Query {
    agenda: [AgendaItem!]!
}

</code></pre>
</li>
<li>
<p>interface</p>
<p><em>Interfaces</em> are another option when dealing with multiple object types that could be returned by a single field. An interface is an abstract type that establishes a list of fields that should be implemented in similar object types. When another type implements the interface, it includes all of the fields from the interface and usually some of its own fields.</p>
<pre><code class="language-java">interface AgendaItem {
    name: String!
    start: DateTime!
    end: DateTime!
}

type StudyGroup implements AgendaItem {
    name: String!
    start: DateTime!
    end: DateTime!
    participants: [User!]!
    topic: String!
}

type Workout implements AgendaItem {
    name: String!
    start: DateTime!
    end: DateTime!
    reps: Int!
}

type Query {
    agenda: [AgendaItem!]!
}
</code></pre>
</li>
<li>
<p>enums</p>
<pre><code class="language-java">enum PhotoCategory {
    SELFIE
    PORTRAIT
    ACTION
    LANDSCAPE
    GRAPHIC
}
</code></pre>
<pre><code class="language-java">type Photo {
    id: ID!
    name: String!
    url: String!
    description: String
    created: DateTime!
    category: PhotoCategory!
}
</code></pre>
</li>
</ul>
<h2 id="graphql的java使用">GraphQL的Java使用</h2>
<p>源码地址：<a href="https://github.com/caijh/samples/tree/master/sample-graphql">https://github.com/caijh/samples/tree/master/sample-graphql</a></p>
<ol>
<li>
<p>引入maven依赖</p>
<pre><code class="language-java">&lt;dependency&gt;
    &lt;groupId&gt;com.graphql-java&lt;/groupId&gt;
    &lt;artifactId&gt;graphql-java&lt;/artifactId&gt;
    &lt;version&gt;11.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;dependency&gt;
            &lt;groupId&gt;com.graphql-java&lt;/groupId&gt;
            &lt;artifactId&gt;graphql-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;5.0.2&lt;/version&gt;
 &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.graphql-java&lt;/groupId&gt;
            &lt;artifactId&gt;graphql-java-tools&lt;/artifactId&gt;
            &lt;version&gt;5.2.4&lt;/version&gt;
        &lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.graphql-java&lt;/groupId&gt;
    &lt;artifactId&gt;graphiql-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;5.0.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>建立表</p>
<pre><code class="language-mysql">create table `author` (
	id bigint primary key auto_increment,
    name varchar(45) not null,
    birthday datetime default null
) engine = InnoDB default charset=utf8 comment '作者';

create table `article` (
	id bigint primary key auto_increment,
    title varchar(100) not null,
    author_id bigint not null,
    content text not null
) engine = InnoDB default charset = utf8 comment '文章';

</code></pre>
</li>
<li>
<p>创建graphqls</p>
<p>schema.graphql</p>
<pre><code class="language-java">scalar Date

type Query {

}

type Mutation {

}
</code></pre>
<p>author.graphqls</p>
<pre><code class="language-java">extend type  Query {
    findAuthorById(id: Int): Author
}

extend type Mutation {
    newAuthor(name: String, birthday: Date): Boolean
}

type Author {
    id: ID
    name: String
    birthday: Date
}

</code></pre>
<p>article.graphqls</p>
<pre><code class="language-java">extend type Query {
    findArticleById(id: Int) : Article
}

extend type Mutation {
    newArticle(title: String, content: String, authorId: Int): Boolean
}

type Article {
    id: ID
    title: String
    content: String
    authorId: Int
}
</code></pre>
</li>
<li>
<p>创建Query和Mutation</p>
<pre><code class="language-java">package com.coding.sample.graphql.component;

import com.coding.sample.graphql.entity.Article;
import com.coding.sample.graphql.entity.Author;
import com.coding.sample.graphql.mapper.ArticleMapper;
import com.coding.sample.graphql.mapper.AuthorMapper;
import com.coxautodev.graphql.tools.GraphQLQueryResolver;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class Query implements GraphQLQueryResolver {

    @Autowired
    private AuthorMapper authorMapper;
    @Autowired
    private ArticleMapper articleMapper;

    public Author findAuthorById(Long id) {
        return authorMapper.selectByPrimaryKey(id);
    }

    public Article findArticleById(Long id) {
        return articleMapper.selectByPrimaryKey(id);
    }

}
</code></pre>
<pre><code class="language-java">package com.coding.sample.graphql.component;

import java.util.Date;

import com.coding.sample.graphql.entity.Article;
import com.coding.sample.graphql.entity.Author;
import com.coding.sample.graphql.mapper.ArticleMapper;
import com.coding.sample.graphql.mapper.AuthorMapper;
import com.coxautodev.graphql.tools.GraphQLMutationResolver;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class Mutation implements GraphQLMutationResolver {

    @Autowired
    private AuthorMapper authorMapper;
    @Autowired
    private ArticleMapper articleMapper;

    public boolean newAuthor(String name, Date birthday) {
        Author author = new Author();
        author.setName(name);
        author.setBirthday(birthday);
        return authorMapper.insert(author) &gt; 0;
    }

    public boolean newArticle(String title, String content, Long authorId) {
        Article article = new Article();
        article.setTitle(title);
        article.setContent(content);
        article.setAuthorId(authorId);
        articleMapper.insert(article);
        return true;
    }

}
</code></pre>
</li>
<li>
<p>测试</p>
</li>
</ol>
<p><img src="https://caijh.github.io//post-images/1561343905414.png" alt="">
<img src="https://caijh.github.io//post-images/1561343911617.png" alt=""></p>
]]></content>
    </entry>
</feed>