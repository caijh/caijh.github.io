<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://caijh.github.io/</id>
    <title>John&apos;s Blog</title>
    <updated>2019-06-30T10:32:21.127Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://caijh.github.io/"/>
    <link rel="self" href="https://caijh.github.io//atom.xml"/>
    <subtitle>搬砖大佬</subtitle>
    <logo>https://caijh.github.io//images/avatar.png</logo>
    <icon>https://caijh.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, John&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[设计模式-观察者模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-guan-cha-zhe-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-guan-cha-zhe-mo-shi">
        </link>
        <updated>2019-06-30T10:30:14.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Define a one-to-many dependency between objects so that when one object changes state,all its dependents are notified and updated automatically.（定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。）</p>
</blockquote>
<h3 id="uml">UML</h3>
<p><img src="https://caijh.github.io//post-images/1561890676877.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Define a one-to-many dependency between objects so that when one object changes state,all its dependents are notified and updated automatically.（定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。）</p>
</blockquote>
<h3 id="uml">UML</h3>
<p><img src="https://caijh.github.io//post-images/1561890676877.png" alt=""></p>
<!-- more -->
<h4 id="代码实现">代码实现</h4>
<pre><code>public abstract class Subject {
     //定义一个观察者数组
     private Vector&lt;Observer&gt; obsVector = new Vector&lt;Observer&gt;();
     //增加一个观察者
     public void addObserver(Observer o){
             this.obsVector.add(o);
     }
     //删除一个观察者
     public void delObserver(Observer o){
             this.obsVector.remove(o);
     }
     //通知所有观察者
     public void notifyObservers(){
             for(Observer o:this.obsVector){
                     o.update();
             }
     }
}
public class ConcreteSubject extends Subject {
     //具体的业务
     public void doSomething(){
             /*
              * do something
              */
             super.notifyObservers();
     }
}
public interface Observer {
     //更新方法
     public void update();
}
public class ConcreteObserver implements Observer {
     //实现更新方法
     public void update() {
             System.out.println(&quot;接收到信息，并进行处理！&quot;);
     }
}
public class Client {
     public static void main(String[] args) {
             //创建一个被观察者
             ConcreteSubject subject = new ConcreteSubject();
             //定义一个观察者
             Observer obs= new ConcreteObserver();
             //观察者观察被观察者
             subject.addObserver(obs);
             //观察者开始活动了
             subject.doSomething();
     }
}
</code></pre>
<h4 id="观察者模式的优点">观察者模式的优点</h4>
<ul>
<li>观察者和被观察者之间是抽象耦合
如此设计，则不管是增加观察者还是被观察者都非常容易扩展，而且在Java中都已经实现的抽象层级的定义，在系统扩展方面更是得心应手。</li>
<li>建立一套触发机制
根据单一职责原则，每个类的职责是单一的，那么怎么把各个单一的职责串联成真实世界的复杂的逻辑关系呢？比如，我们去打猎，打死了一只母鹿，母鹿有三个幼崽，因失去了母鹿而饿死，尸体又被两只秃鹰争抢，因分配不均，秃鹰开始斗殴，然后羸弱的秃鹰死掉，生存下来的秃鹰，则因此扩大了地盘……这就是一个触发机制，形成了一个触发链。观察者模式可以完美地实现这里的链条形式。</li>
</ul>
<h4 id="观察者模式的缺点">观察者模式的缺点</h4>
<p>观察者模式需要考虑一下开发效率和运行效率问题，一个被观察者，多个观察者，开发和调试就会比较复杂，而且在Java中消息的通知默认是顺序执行，一个观察者卡壳，会影响整体的执行效率。在这种情况下，一般考虑采用异步的方式。
多级触发时的效率更是让人担忧，大家在设计时注意考虑。</p>
<h4 id="观察者模式的使用场景">观察者模式的使用场景</h4>
<ul>
<li>关联行为场景。需要注意的是，关联行为是可拆分的，而不是“组合”关系。</li>
<li>事件多级触发场景。</li>
<li>跨系统的消息交换场景，如消息队列的处理机制。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-组合模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-zu-he-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-zu-he-mo-shi">
        </link>
        <updated>2019-06-30T10:05:20.000Z</updated>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Compose objects into tree structures to represent part-whole hierarchies.Composite lets clients treat individual objects and compositions of objects uniformly.（将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561889214924.png" alt=""></p>
<h4 id="代码实现">代码实现</h4>
<pre><code>public abstract class Component {
     //个体和整体都具有的共享
     public void doSomething(){
             //编写业务逻辑
     }
}
public class Composite extends Component {
     //构件容器
     private ArrayList&lt;Component&gt; componentArrayList = new ArrayList&lt;Component&gt;();
     //增加一个叶子构件或树枝构件
     public void add(Component component){
             this.componentArrayList.add(component);
     }
     //删除一个叶子构件或树枝构件
     public void remove(Component component){
             this.componentArrayList.remove(component);
     }
     //获得分支下的所有叶子构件和树枝构件
     public ArrayList&lt;Component&gt; getChildren(){
             return this.componentArrayList;
     }
}
public class Leaf extends Component {
     /*
      * 可以覆写父类方法
      * public void doSomething(){
      * 
      * }
      */
}
public class Client {
     public static void main(String[] args) {
            //创建一个根节点
             Composite root = new Composite();
             root.doSomething();
             //创建一个树枝构件
             Composite branch = new Composite();
             //创建一个叶子节点
             Leaf leaf = new Leaf();
             //建立整体
             root.add(branch);
             branch.add(leaf);          
     }
     //通过递归遍历树
     public static void display(Composite root){
             for(Component c:root.getChildren()){
                  if(c instanceof Leaf){ //叶子节点
                          c.doSomething();
                  }else{ //树枝节点
                          display((Composite)c);
                  }
             }
     }
}
</code></pre>
<h4 id="组合模式的优点">组合模式的优点</h4>
<ul>
<li>高层模块调用简单
一棵树形机构中的所有节点都是Component，局部和整体对调用者来说没有任何区别，也就是说，高层模块不必关心自己处理的是单个对象还是整个组合结构，简化了高层模块的代码。</li>
<li>节点自由增加
使用了组合模式后，我们可以看看，如果想增加一个树枝节点、树叶节点是不是都很容易，只要找到它的父节点就成，非常容易扩展，符合开闭原则，对以后的维护非常有利。</li>
</ul>
<h4 id="组合模式的缺点">组合模式的缺点</h4>
<p>组合模式有一个非常明显的缺点，看到我们在场景类中的定义，提到树叶和树枝使用时的定义了吗？直接使用了实现类！这在面向接口编程上是很不恰当的，与依赖倒置原则冲突，读者在使用的时候要考虑清楚，它限制了你接口的影响范围。</p>
<h4 id="组合模式使用场景">组合模式使用场景</h4>
<ul>
<li>想要表示对象间部分-整体的层次关系</li>
<li>想让客户端略过组合与个体的差异</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-迭代器模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-die-dai-qi-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-die-dai-qi-mo-shi">
        </link>
        <updated>2019-06-30T07:29:38.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.（它提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561879827619.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.（它提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561879827619.png" alt=""></p>
<!-- more -->
<h4 id="代码实现">代码实现</h4>
<pre><code>public interface Iterator {
     //遍历到下一个元素
     public Object next();
     //是否已经遍历到尾部
     public boolean hasNext();
     //删除当前指向的元素
     public boolean remove();
}
public class ConcreteIterator implements Iterator {
     private Vector vector = new Vector();
     //定义当前游标
     public int cursor = 0;
     @SuppressWarnings(&quot;unchecked&quot;)
     public ConcreteIterator(Vector _vector){
             this.vector = _vector;
     }
     //判断是否到达尾部
     public boolean hasNext() {
             if(this.cursor == this.vector.size()){
                    return false;
             }else{
                    return true;
             }
     }
     //返回下一个元素
     public Object next() {
             Object result = null;
             if(this.hasNext()){
                    result = this.vector.get(this.cursor++);
             }else{
                    result = null;
             }
             return result;
     }
     //删除当前元素
     public boolean remove() {
             this.vector.remove(this.cursor);
             return true;
     }
}
public interface Aggregate {
     //是容器必然有元素的增加
     public void add(Object object);
     //减少元素
     public void remove(Object object);
     //由迭代器来遍历所有的元素
     public Iterator iterator();
}
public class ConcreteAggregate implements Aggregate {
     //容纳对象的容器
     private Vector vector = new Vector();
     //增加一个元素
     public void add(Object object) {
             this.vector.add(object);
     }
     //返回迭代器对象
     public Iterator iterator() {
             return new ConcreteIterator(this.vector);
     }
     //删除一个元素
     public void remove(Object object) {
             this.remove(object);
     }
}
public class Client {
     public static void main(String[] args) {
             //声明出容器
             Aggregate agg = new ConcreteAggregate();
             //产生对象数据放进去
             agg.add(&quot;abc&quot;);
             agg.add(&quot;aaa&quot;);
             agg.add(&quot;1234&quot;);     
             //遍历一下
             Iterator iterator = agg.iterator();
             while(iterator.hasNext()){
                     System.out.println(iterator.next());
             }
     }
}
</code></pre>
<h4 id="使用迭代器模式的场景">使用迭代器模式的场景</h4>
<ul>
<li>访问聚合对象的内容，但不想暴露它的表现</li>
<li>要支持多次访问聚合对象</li>
<li>要提供统一方式访问不同聚合对象数据结构</li>
</ul>
<h4 id="jdk中的迭代器模式">JDK中的迭代器模式</h4>
<ul>
<li>java.util.Iterator</li>
<li>java.util.Enumeration</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-适配器模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-gua-pei-qi-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-gua-pei-qi-mo-shi">
        </link>
        <updated>2019-06-30T06:59:48.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Convert the interface of a class into another interface clients expect.Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.（将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。）</p>
</blockquote>
<h4 id="uml图">UML图</h4>
<p><img src="https://caijh.github.io//post-images/1561879601059.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Convert the interface of a class into another interface clients expect.Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.（将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。）</p>
</blockquote>
<h4 id="uml图">UML图</h4>
<p><img src="https://caijh.github.io//post-images/1561879601059.png" alt=""></p>
<!-- more -->
<h4 id="代码实现">代码实现</h4>
<pre><code>public interface Target {
     //目标角色有自己的方法
     public void request();
}
public class ConcreteTarget implements Target {
     public void request() {
             System.out.println(&quot;if you need any help,pls call me!&quot;);   }
}
public class Adaptee {
     //原有的业务逻辑
     public void doSomething(){
             System.out.println(&quot;I'm kind of busy,leave me alone,pls!&quot;);
     }
}
public class Adapter extends Adaptee implements Target {
     public void request() {
             super.doSomething();
     }
}
public class Client {
     public static void main(String[] args) {
             //原有的业务逻辑
             Target target = new ConcreteTarget();
             target.request();
             //现在增加了适配器角色后的业务逻辑
             Target target2 = new Adapter();
             target2.request();
     }
}
</code></pre>
<h4 id="适配器模式的优点">适配器模式的优点</h4>
<ul>
<li>适配器模式可以让两个没有任何关系的类在一起运行，只要适配器这个角色能够搞定他们就成。</li>
<li>增加了类的透明性
想想看，我们访问的Target目标角色，但是具体的实现都委托给了源角色，而这些对高层次模块是透明的，也是它不需要关心的。</li>
<li>提高了类的复用度
当然了，源角色在原有的系统中还是可以正常使用，而在目标角色中也可以充当新的演员。</li>
<li>灵活性非常好
某一天，突然不想要适配器，没问题，删除掉这个适配器就可以了，其他的代码都不用修改，基本上就类似一个灵活的构件，想用就用，不想就卸载。</li>
</ul>
<h4 id="适配器模式的使用场景">适配器模式的使用场景</h4>
<p>适配器应用的场景只要记住一点就足够了：你有动机修改一个已经投产中的接口时，适配器模式可能是最适合你的模式。比如系统扩展了，需要使用一个已有或新建立的类，但这个类又不符合系统的接口，怎么办？使用适配器模式，这也是我们例子中提到的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-策略模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-ce-lue-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-ce-lue-mo-shi">
        </link>
        <updated>2019-06-30T06:55:08.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Define a family of algorithms,encapsulate each one,and make them interchangeable.（定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561877754788.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Define a family of algorithms,encapsulate each one,and make them interchangeable.（定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561877754788.png" alt=""></p>
<!-- more -->
<h4 id="代码实现">代码实现</h4>
<pre><code>public interface Strategy {
     //策略模式的运算法则
     public void doSomething();
}
public class ConcreteStrategy1 implements Strategy {
     public void doSomething() {
             System.out.println(&quot;具体策略1的运算法则&quot;);
     }
}
public class ConcreteStrategy2 implements Strategy {
     public void doSomething() {
             System.out.println(&quot;具体策略2的运算法则&quot;);
     }
}
public class Context {
     //抽象策略
     private Strategy strategy = null;  
     //构造函数设置具体策略
     public Context(Strategy _strategy){
             this.strategy = _strategy;
     }
     //封装后的策略方法
     public void doAnythinig(){
             this.strategy.doSomething();
     }
}
public class Client {
     public static void main(String[] args) {
             //声明一个具体的策略
             Strategy strategy = new ConcreteStrategy1();
             //声明上下文对象
             Context context = new Context(strategy);
             //执行封装后的方法
             context.doAnythinig();
     }
}
</code></pre>
<h4 id="策略模式的优点">策略模式的优点</h4>
<ul>
<li>算法可以自由切换
这是策略模式本身定义的，只要实现抽象策略，它就成为策略家族的一个成员，通过封装角色对其进行封装，保证对外提供“可自由切换”的策略。</li>
<li>避免使用多重条件判断
如果没有策略模式，我们想想看会是什么样子？一个策略家族有5个策略算法，一会要使用A策略，一会要使用B策略，怎么设计呢？使用多重的条件语句？多重条件语句不易维护，而且出错的概率大大增强。使用策略模式后，可以由其他模块决定采用何种策略，策略家族对外提供的访问接口就是封装类，简化了操作，同时避免了条件语句判断。</li>
<li>扩展性良好
这甚至都不用说是它的优点，因为它太明显了。在现有的系统中增加一个策略太容易了，只要实现接口就可以了，其他都不用修改，类似于一个可反复拆卸的插件，这大大地符合了OCP原则。</li>
</ul>
<h4 id="策略模式的缺点">策略模式的缺点</h4>
<ul>
<li>策略类数量增多
每一个策略都是一个类，复用的可能性很小，类数量增多。</li>
<li>所有的策略类都需要对外暴露
上层模块必须知道有哪些策略，然后才能决定使用哪一个策略，这与迪米特法则是相违背的，我只是想使用了一个策略，我凭什么就要了解这个策略呢？那要你的封装类还有什么意义？这是原装策略模式的一个缺点，幸运的是，我们可以使用其他模式来修正这个缺陷，如工厂方法模式、代理模式或享元模式。</li>
</ul>
<h4 id="jdk中的策略模式">JDK中的策略模式</h4>
<ul>
<li>java.util.Comparator#compare()</li>
<li>javax.servlet.http.HttpServlet</li>
<li>javax.servlet.Filter#doFilter()</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-装饰模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-zhuang-shi-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-zhuang-shi-mo-shi">
        </link>
        <updated>2019-06-30T06:46:44.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Attach additional responsibilities to an object dynamically keeping the same interface.Decorators provide a flexible alternative to subclassing for extending functionality.（动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561877503426.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Attach additional responsibilities to an object dynamically keeping the same interface.Decorators provide a flexible alternative to subclassing for extending functionality.（动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561877503426.png" alt=""></p>
<!-- more -->
<h4 id="代码实现">代码实现</h4>
<pre><code>/**
* Component是一个接口或者是抽象类，就是定义我们最核心的对象，也就是最原始的对象
*/
public abstract class Component {
     //抽象的方法
     public abstract void operate();
}
public class ConcreteComponent extends Component {
     //具体实现
     @Override
     public void operate() {
             System.out.println(&quot;do Something&quot;);
     }
}
public abstract class Decorator extends Component {
     private Component component = null;        
     //通过构造函数传递被修饰者
     public Decorator(Component _component){
             this.component = _component;
     }
     //委托给被修饰者执行
     @Override
     public void operate() {
             this.component.operate();
     }
}
public class ConcreteDecorator1 extends Decorator {
     //定义被修饰者
     public ConcreteDecorator1(Component _component){
             super(_component);
     }
     //定义自己的修饰方法
     private void method1(){
             System.out.println(&quot;method1 修饰&quot;);
     }
     //重写父类的Operation方法
     public void operate(){
             this.method1();
             super.operate();
     }
}
public class ConcreteDecorator2 extends Decorator {
     //定义被修饰者
     public ConcreteDecorator2(Component _component){
             super(_component);
     }
     //定义自己的修饰方法
     private void method2(){
             System.out.println(&quot;method2修饰&quot;);
     }
     //重写父类的Operation方法
     public void operate(){
             super.operate();
             this.method2();
     }
}
public class Client {
     public static void main(String[] args) {
             Component component = new ConcreteComponent();
             //第一次修饰
             component = new ConcreteDecorator1(component);
             //第二次修饰
             component = new ConcreteDecorator2(component);
             //修饰后运行
             component.operate();
     }
}
</code></pre>
<h4 id="装饰者模式的优点">装饰者模式的优点</h4>
<ul>
<li>装饰类和被装饰类可以独立发展，而不会相互耦合。换句话说，Component类无须知道Decorator类，Decorator类是从外部来扩展Component类的功能，而Decorator也不用知道具体的构件。</li>
<li>装饰模式是继承关系的一个替代方案。我们看装饰类Decorator，不管装饰多少层，返回的对象还是Component，实现的还是is-a的关系。</li>
<li>装饰模式可以动态地扩展一个实现类的功能，这不需要多说，装饰模式的定义就是如此。</li>
</ul>
<h4 id="装饰者模式的缺点">装饰者模式的缺点</h4>
<p>对于装饰模式记住一点就足够了：多层的装饰是比较复杂的。为什么会复杂呢？你想想看，就像剥洋葱一样，你剥到了最后才发现是最里层的装饰出现了问题，想象一下工作量吧，因此，尽量减少装饰类的数量，以便降低系统的复杂度。</p>
<h4 id="装饰者模式的使用场景">装饰者模式的使用场景</h4>
<ul>
<li>需要扩展一个类的功能，或给一个类增加附加功能。</li>
<li>需要动态地给一个对象增加功能，这些功能可以再动态地撤销。</li>
<li>需要为一批的兄弟类进行改装或加装功能，当然是首选装饰模式。</li>
</ul>
<h4 id="jdk中的装饰器模式">JDK中的装饰器模式</h4>
<ul>
<li>java.io.BufferedInputStream(InputStream)</li>
<li>java.io.DataInputStream(InputStream)</li>
<li>java.io.BufferedOutputStream(OutputStream)</li>
<li>java.util.zip.ZipOutputStream(OutputStream)</li>
<li>java.util.Collections#checked<a href="">List|Map|Set|SortedSet|SortedMap</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-责任链模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-ze-ren-lian-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-ze-ren-lian-mo-shi">
        </link>
        <updated>2019-06-30T06:31:43.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request.Chain the receiving objects and pass the request along the chain until an object handles it.（使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561876377460.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request.Chain the receiving objects and pass the request along the chain until an object handles it.（使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561876377460.png" alt=""></p>
<!-- more -->
<h4 id="代码实现">代码实现</h4>
<pre><code>public abstract class Handler {
     private Handler nextHandler;
     //每个处理者都必须对请求做出处理
     public final Response handleMessage(Request request){
             Response response = null;  
             //判断是否是自己的处理级别
             if(this.getHandlerLevel().equals(request.getRequestLevel())){
                    response = this.echo(request);
             }else{  //不属于自己的处理级别
                    //判断是否有下一个处理者
                    if(this.nextHandler != null){
                            response = this.nextHandler.handleMessage(request);
                    }else{
                            //没有适当的处理者，业务自行处理
                    }
             }
             return response;
     }
     //设置下一个处理者是谁
     public void setNext(Handler _handler){
             this.nextHandler = _handler;
     }
     //每个处理者都有一个处理级别
     protected abstract Level getHandlerLevel();
     //每个处理者都必须实现处理任务
     protected abstract Response echo(Request request);
}

public class ConcreteHandler1 extends Handler {
     //定义自己的处理逻辑
     protected Response echo(Request request) {
             //完成处理逻辑
             return null;
     }
     //设置自己的处理级别
     protected Level getHandlerLevel() {
             //设置自己的处理级别
             return null;
     }
}
public class ConcreteHandler2 extends Handler {
     //定义自己的处理逻辑
     protected Response echo(Request request) {
             //完成处理逻辑
             return null;
     }
     //设置自己的处理级别
     protected Level getHandlerLevel() {
             //设置自己的处理级别
             return null;
     }
}
public class ConcreteHandler3 extends Handler {
     //定义自己的处理逻辑
     protected Response echo(Request request) {
             //完成处理逻辑
             return null;
     }
     //设置自己的处理级别
     protected Level getHandlerLevel() {
             //设置自己的处理级别
             return null;
     }
}

public class Level {
     //定义一个请求和处理等级
}
public class Request {
     //请求的等级
     public Level getRequestLevel(){
             return null;
     }
}
public class Response {
     //处理者返回的数据
}

public class Client {
     public static void main(String[] args) {
             //声明所有的处理节点
             Handler handler1 = new ConcreteHandler1();
             Handler handler2 = new ConcreteHandler2();
             Handler handler3 = new ConcreteHandler3();
             //设置链中的阶段顺序1--&gt;2--&gt;3
             handler1.setNext(handler2);
             handler2.setNext(handler3);
             //提交请求，返回结果
             Response response = handler1.handlerMessage(new Request());
     }
}
</code></pre>
<h4 id="责任链模式的优点">责任链模式的优点：</h4>
<p>责任链模式非常显著的优点是将请求和处理分开。请求者可以不用知道是谁处理的，处理者可以不用知道请求的全貌（例如在J2EE项目开发中，可以剥离出无状态Bean由责任链处理），两者解耦，提高系统的灵活性。</p>
<h4 id="责任链模式的缺点">责任链模式的缺点：</h4>
<p>责任链有两个非常显著的缺点：一是性能问题，每个请求都是从链头遍历到链尾，特别是在链比较长的时候，性能是一个非常大的问题。二是调试不很方便，特别是链条比较长，环节比较多的时候，由于采用了类似递归的方式，调试的时候逻辑可能比较复杂。</p>
<h3 id="jdk中的责任链模式">JDK中的责任链模式：</h3>
<ul>
<li>java.util.logging.Logger#log()</li>
<li>avax.servlet.Filter#doFilter()</li>
</ul>
<h4 id="何时使用刚责任链模式">何时使用刚责任链模式</h4>
<ul>
<li>一个请求可以被超过一个对象处理，请求处理器之间没有优先级</li>
<li>一组对象可以动态地处理一个请求。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-命令模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-ming-ling-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-ming-ling-mo-shi">
        </link>
        <updated>2019-06-30T06:11:26.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>命令模式是一个高内聚的模式，其定义为：Encapsulate a request as an object,thereby letting you parameterize clients with different requests,queue or log requests,and support undoable operations.（将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561875177967.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>命令模式是一个高内聚的模式，其定义为：Encapsulate a request as an object,thereby letting you parameterize clients with different requests,queue or log requests,and support undoable operations.（将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561875177967.png" alt=""></p>
<!-- more -->
<h4 id="代码实现">代码实现</h4>
<pre><code>public abstract class Receiver {
     //抽象接收者，定义每个接收者都必须完成的业务
     public abstract void doSomething();
}
public class ConcreteReciver1 extends Receiver{    
     //每个接收者都必须处理一定的业务逻辑
     public void doSomething(){
     }
}
public class ConcreteReciver2 extends Receiver{ 
     //每个接收者都必须处理一定的业务逻辑
     public void doSomething(){
     }
}
public abstract class Command {
     //每个命令类都必须有一个执行命令的方法
     public abstract void execute();
}
public class ConcreteCommand1 extends Command {
     //对哪个Receiver类进行命令处理
     private Receiver receiver; 
     //构造函数传递接收者
     public ConcreteCommand1(Receiver _receiver){
             this.receiver = _receiver;
     }
     //必须实现一个命令
     public void execute() {
             //业务处理
             this.receiver.doSomething();
     }
}
public class ConcreteCommand2 extends Command {
     //哪个Receiver类进行命令处理
     private Receiver receiver;
     //构造函数传递接收者
     public ConcreteCommand2(Receiver _receiver){
             this.receiver = _receiver;
     }
     //必须实现一个命令
     public void execute() {
             //业务处理
             this.receiver.doSomething();
     }
}
public class Invoker {
     private Command command;
     //受气包，接受命令
     public void setCommand(Command _command){
             this.command = _command;
     }
     //执行命令
     public void action(){
             this.command.execute();
     }
}
public class Client {
     public static void main(String[] args) {
             //首先声明调用者Invoker
             Invoker invoker = new Invoker();
             //定义接收者
             Receiver receiver = new ConcreteReciver1();
             //定义一个发送给接收者的命令
             Command command = new ConcreteCommand1(receiver);
             //把命令交给调用者去执行
             invoker.setCommand(command);
             invoker.action();
     }
}
</code></pre>
<h4 id="命令模式的优点">命令模式的优点</h4>
<ul>
<li>类间解耦
调用者角色与接收者角色之间没有任何依赖关系，调用者实现功能时只需调用Command抽象类的execute方法就可以，不需要了解到底是哪个接收者执行。</li>
<li>可扩展性
Command的子类可以非常容易地扩展，而调用者Invoker和高层次的模块Client不产生严重的代码耦合。</li>
<li>命令模式结合其他模式会更优秀
命令模式可以结合责任链模式，实现命令族解析任务；结合模板方法模式，则可以减少Command子类的膨胀问题。</li>
</ul>
<h4 id="命令模式的缺点">命令模式的缺点</h4>
<p>命令模式也是有缺点的，请看Command的子类：如果有N个命令，问题就出来了，Command的子类就可不是几个，而是N个，这个类膨胀得非常大，这个就需要读者在项目中慎重考虑使用。</p>
<h4 id="jdk中的命令模式">JDK中的命令模式</h4>
<ul>
<li>java.lang.Runnable</li>
<li>javax.swing.Action</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-中介者模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-zhong-jie-zhe-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-zhong-jie-zhe-mo-shi">
        </link>
        <updated>2019-06-24T15:10:09.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>中介者模式的定义为：Define an object that encapsulates how a set of objects interact.Mediator promotes loose coupling by keeping objects from referring to each other explicitly,and it lets you vary their interaction independently.（用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561389056024.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>中介者模式的定义为：Define an object that encapsulates how a set of objects interact.Mediator promotes loose coupling by keeping objects from referring to each other explicitly,and it lets you vary their interaction independently.（用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561389056024.png" alt=""></p>
<!-- more -->
<h4 id="代码实现">代码实现</h4>
<pre><code>public abstract class Mediator {
     //定义同事类
     protected ConcreteColleague1 c1;
     protected ConcreteColleague2 c2;
     //通过getter/setter方法把同事类注入进来
     public ConcreteColleague1 getC1() {
             return c1;
     }
     public void setC1(ConcreteColleague1 c1) {
             this.c1 = c1;
     }
     public ConcreteColleague2 getC2() {
             return c2;
     }
     public void setC2(ConcreteColleague2 c2) {
             this.c2 = c2;
     }
     //中介者模式的业务逻辑
     public abstract void doSomething1();
     public abstract void doSomething2();
}

public class ConcreteMediator extends Mediator {
     @Override
     public void doSomething1() {
             //调用同事类的方法，只要是public方法都可以调用
             super.c1.selfMethod1();
             super.c2.selfMethod2();
     }
     public void doSomething2() {
             super.c1.selfMethod1();
             super.c2.selfMethod2();
     }
}

public abstract class Colleague {
     protected Mediator mediator;
     public Colleague(Mediator _mediator){
             this.mediator = _mediator;
     }
}
public class ConcreteColleague1 extends Colleague {
     //通过构造函数传递中介者
     public ConcreteColleague1(Mediator _mediator){
             super(_mediator);
     }
     //自有方法 self-method
     public void selfMethod1(){
             //处理自己的业务逻辑
     }
     //依赖方法 dep-method
     public void depMethod1(){
             //处理自己的业务逻辑
             //自己不能处理的业务逻辑，委托给中介者处理
             super.mediator.doSomething1();
     }
}
public class ConcreteColleague2 extends Colleague {
     //通过构造函数传递中介者
     public ConcreteColleague2(Mediator _mediator){
             super(_mediator);
     }
     //自有方法 self-method
     public void selfMethod2(){
             //处理自己的业务逻辑
     }
     //依赖方法 dep-method
     public void depMethod2(){
             //处理自己的业务逻辑
             //自己不能处理的业务逻辑，委托给中介者处理
             super.mediator.doSomething2();
     }
}

</code></pre>
<h4 id="中介者模式的优点">中介者模式的优点</h4>
<p>中介者模式的优点就是减少类间的依赖，把原有的一对多的依赖变成了一对一的依赖，同事类只依赖中介者，减少了依赖，当然同时也降低了类间的耦合。</p>
<h4 id="中介者模式的缺点">中介者模式的缺点</h4>
<p>中介者模式的缺点就是中介者会膨胀得很大，而且逻辑复杂，原本N个对象直接的相互依赖关系转换为中介者和同事类的依赖关系，同事类越多，中介者的逻辑就越复杂。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-原型模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-yuan-xing-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-yuan-xing-mo-shi">
        </link>
        <updated>2019-06-24T15:06:00.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Specify the kinds of objects to create using a prototypical instance,and create new objects by copying this prototype.（用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561388832916.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Specify the kinds of objects to create using a prototypical instance,and create new objects by copying this prototype.（用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561388832916.png" alt=""></p>
<!-- more -->
<h4 id="代码实现">代码实现</h4>
<pre><code>public class PrototypeClass  implements Cloneable{
     //覆写父类Object方法
     @Override
     public PrototypeClass clone(){
             PrototypeClass prototypeClass = null;
             try {
                    prototypeClass = (PrototypeClass)super.clone();
             } catch (CloneNotSupportedException e) {
                    //异常处理
             }
             return prototypeClass;
     }
}
</code></pre>
<h4 id="原型模式的优点">原型模式的优点：</h4>
<ul>
<li>性能优良
原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。</li>
<li>逃避构造函数的约束
这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的。优点就是减少了约束，缺点也是减少了约束，需要大家在实际应用时考虑。</li>
</ul>
<h4 id="原型模式的使用场景">原型模式的使用场景</h4>
<ul>
<li>资源优化场景
类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。</li>
<li>性能和安全要求的场景
通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。</li>
<li>一个对象多个修改者的场景
一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。</li>
</ul>
<h4 id="jdk中的原型模式">JDK中的原型模式</h4>
<ul>
<li>java.lang.Object#clone()</li>
<li>java.lang.Cloneable</li>
</ul>
]]></content>
    </entry>
</feed>