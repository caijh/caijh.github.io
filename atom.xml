<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://caijh.github.io/</id>
    <title>John&apos;s Blog</title>
    <updated>2019-06-30T06:29:16.908Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://caijh.github.io/"/>
    <link rel="self" href="https://caijh.github.io//atom.xml"/>
    <subtitle>搬砖大佬</subtitle>
    <logo>https://caijh.github.io//images/avatar.png</logo>
    <icon>https://caijh.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, John&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[设计模式-命令模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-ming-ling-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-ming-ling-mo-shi">
        </link>
        <updated>2019-06-30T06:11:26.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>命令模式是一个高内聚的模式，其定义为：Encapsulate a request as an object,thereby letting you parameterize clients with different requests,queue or log requests,and support undoable operations.（将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561875177967.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>命令模式是一个高内聚的模式，其定义为：Encapsulate a request as an object,thereby letting you parameterize clients with different requests,queue or log requests,and support undoable operations.（将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561875177967.png" alt=""></p>
<!-- more -->
<h4 id="代码实现">代码实现</h4>
<pre><code>public abstract class Receiver {
     //抽象接收者，定义每个接收者都必须完成的业务
     public abstract void doSomething();
}
public class ConcreteReciver1 extends Receiver{    
     //每个接收者都必须处理一定的业务逻辑
     public void doSomething(){
     }
}
public class ConcreteReciver2 extends Receiver{ 
     //每个接收者都必须处理一定的业务逻辑
     public void doSomething(){
     }
}
public abstract class Command {
     //每个命令类都必须有一个执行命令的方法
     public abstract void execute();
}
public class ConcreteCommand1 extends Command {
     //对哪个Receiver类进行命令处理
     private Receiver receiver; 
     //构造函数传递接收者
     public ConcreteCommand1(Receiver _receiver){
             this.receiver = _receiver;
     }
     //必须实现一个命令
     public void execute() {
             //业务处理
             this.receiver.doSomething();
     }
}
public class ConcreteCommand2 extends Command {
     //哪个Receiver类进行命令处理
     private Receiver receiver;
     //构造函数传递接收者
     public ConcreteCommand2(Receiver _receiver){
             this.receiver = _receiver;
     }
     //必须实现一个命令
     public void execute() {
             //业务处理
             this.receiver.doSomething();
     }
}
public class Invoker {
     private Command command;
     //受气包，接受命令
     public void setCommand(Command _command){
             this.command = _command;
     }
     //执行命令
     public void action(){
             this.command.execute();
     }
}
public class Client {
     public static void main(String[] args) {
             //首先声明调用者Invoker
             Invoker invoker = new Invoker();
             //定义接收者
             Receiver receiver = new ConcreteReciver1();
             //定义一个发送给接收者的命令
             Command command = new ConcreteCommand1(receiver);
             //把命令交给调用者去执行
             invoker.setCommand(command);
             invoker.action();
     }
}
</code></pre>
<h4 id="命令模式的优点">命令模式的优点</h4>
<ul>
<li>类间解耦
调用者角色与接收者角色之间没有任何依赖关系，调用者实现功能时只需调用Command抽象类的execute方法就可以，不需要了解到底是哪个接收者执行。</li>
<li>可扩展性
Command的子类可以非常容易地扩展，而调用者Invoker和高层次的模块Client不产生严重的代码耦合。</li>
<li>命令模式结合其他模式会更优秀
命令模式可以结合责任链模式，实现命令族解析任务；结合模板方法模式，则可以减少Command子类的膨胀问题。</li>
</ul>
<h4 id="命令模式的缺点">命令模式的缺点</h4>
<p>命令模式也是有缺点的，请看Command的子类：如果有N个命令，问题就出来了，Command的子类就可不是几个，而是N个，这个类膨胀得非常大，这个就需要读者在项目中慎重考虑使用。</p>
<h4 id="jdk中的命令模式">JDK中的命令模式</h4>
<ul>
<li>java.lang.Runnable</li>
<li>javax.swing.Action</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-中介者模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-zhong-jie-zhe-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-zhong-jie-zhe-mo-shi">
        </link>
        <updated>2019-06-24T15:10:09.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>中介者模式的定义为：Define an object that encapsulates how a set of objects interact.Mediator promotes loose coupling by keeping objects from referring to each other explicitly,and it lets you vary their interaction independently.（用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561389056024.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>中介者模式的定义为：Define an object that encapsulates how a set of objects interact.Mediator promotes loose coupling by keeping objects from referring to each other explicitly,and it lets you vary their interaction independently.（用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561389056024.png" alt=""></p>
<!-- more -->
<h4 id="代码实现">代码实现</h4>
<pre><code>public abstract class Mediator {
     //定义同事类
     protected ConcreteColleague1 c1;
     protected ConcreteColleague2 c2;
     //通过getter/setter方法把同事类注入进来
     public ConcreteColleague1 getC1() {
             return c1;
     }
     public void setC1(ConcreteColleague1 c1) {
             this.c1 = c1;
     }
     public ConcreteColleague2 getC2() {
             return c2;
     }
     public void setC2(ConcreteColleague2 c2) {
             this.c2 = c2;
     }
     //中介者模式的业务逻辑
     public abstract void doSomething1();
     public abstract void doSomething2();
}

public class ConcreteMediator extends Mediator {
     @Override
     public void doSomething1() {
             //调用同事类的方法，只要是public方法都可以调用
             super.c1.selfMethod1();
             super.c2.selfMethod2();
     }
     public void doSomething2() {
             super.c1.selfMethod1();
             super.c2.selfMethod2();
     }
}

public abstract class Colleague {
     protected Mediator mediator;
     public Colleague(Mediator _mediator){
             this.mediator = _mediator;
     }
}
public class ConcreteColleague1 extends Colleague {
     //通过构造函数传递中介者
     public ConcreteColleague1(Mediator _mediator){
             super(_mediator);
     }
     //自有方法 self-method
     public void selfMethod1(){
             //处理自己的业务逻辑
     }
     //依赖方法 dep-method
     public void depMethod1(){
             //处理自己的业务逻辑
             //自己不能处理的业务逻辑，委托给中介者处理
             super.mediator.doSomething1();
     }
}
public class ConcreteColleague2 extends Colleague {
     //通过构造函数传递中介者
     public ConcreteColleague2(Mediator _mediator){
             super(_mediator);
     }
     //自有方法 self-method
     public void selfMethod2(){
             //处理自己的业务逻辑
     }
     //依赖方法 dep-method
     public void depMethod2(){
             //处理自己的业务逻辑
             //自己不能处理的业务逻辑，委托给中介者处理
             super.mediator.doSomething2();
     }
}

</code></pre>
<h4 id="中介者模式的优点">中介者模式的优点</h4>
<p>中介者模式的优点就是减少类间的依赖，把原有的一对多的依赖变成了一对一的依赖，同事类只依赖中介者，减少了依赖，当然同时也降低了类间的耦合。</p>
<h4 id="中介者模式的缺点">中介者模式的缺点</h4>
<p>中介者模式的缺点就是中介者会膨胀得很大，而且逻辑复杂，原本N个对象直接的相互依赖关系转换为中介者和同事类的依赖关系，同事类越多，中介者的逻辑就越复杂。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-原型模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-yuan-xing-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-yuan-xing-mo-shi">
        </link>
        <updated>2019-06-24T15:06:00.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Specify the kinds of objects to create using a prototypical instance,and create new objects by copying this prototype.（用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561388832916.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Specify the kinds of objects to create using a prototypical instance,and create new objects by copying this prototype.（用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561388832916.png" alt=""></p>
<!-- more -->
<h4 id="代码实现">代码实现</h4>
<pre><code>public class PrototypeClass  implements Cloneable{
     //覆写父类Object方法
     @Override
     public PrototypeClass clone(){
             PrototypeClass prototypeClass = null;
             try {
                    prototypeClass = (PrototypeClass)super.clone();
             } catch (CloneNotSupportedException e) {
                    //异常处理
             }
             return prototypeClass;
     }
}
</code></pre>
<h4 id="原型模式的优点">原型模式的优点：</h4>
<ul>
<li>性能优良
原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。</li>
<li>逃避构造函数的约束
这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的。优点就是减少了约束，缺点也是减少了约束，需要大家在实际应用时考虑。</li>
</ul>
<h4 id="原型模式的使用场景">原型模式的使用场景</h4>
<ul>
<li>资源优化场景
类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。</li>
<li>性能和安全要求的场景
通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。</li>
<li>一个对象多个修改者的场景
一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。</li>
</ul>
<h4 id="jdk中的原型模式">JDK中的原型模式</h4>
<ul>
<li>java.lang.Object#clone()</li>
<li>java.lang.Cloneable</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-代理模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-dai-li-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-dai-li-mo-shi">
        </link>
        <updated>2019-06-24T15:03:20.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Provide a surrogate or placeholder for another object to control access to it.（为其他对象提供一种代理以控制对这个对象的访问。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561388635995.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Provide a surrogate or placeholder for another object to control access to it.（为其他对象提供一种代理以控制对这个对象的访问。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561388635995.png" alt=""></p>
<!-- more -->
<h4 id="代码实现">代码实现</h4>
<pre><code>public interface Subject {
     //定义一个方法
     public void request();
}
public class RealSubject implements Subject {
     //实现方法
     public void request() {
             //业务逻辑处理
     }
}
public class Proxy implements Subject {
     //要代理哪个实现类
     private Subject subject = null;    
     //默认被代理者
     public Proxy(){
             this.subject = new RealSubject();
     }
     //通过构造函数传递代理者
     public Proxy(Object...objects ){
     }
     //实现接口中定义的方法
     public void request() {
             this.before();
             this.subject.request();
             this.after();
     }
     //预处理
     private void before(){
             //do something
     }
     //善后处理
     private void after(){
             //do something
     }
}
</code></pre>
<h4 id="代理模式的优点">代理模式的优点</h4>
<ul>
<li>职责清晰
真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件事务，附带的结果就是编程简洁清晰。</li>
<li>职责清晰
真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件事务，附带的结果就是编程简洁清晰。</li>
<li>智能化</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-建造者模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-jian-zao-zhe-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-jian-zao-zhe-mo-shi">
        </link>
        <updated>2019-06-24T14:57:23.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Separate the construction of a complex object from its representation so that the same construction process can create different representations.（将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561388283844.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Separate the construction of a complex object from its representation so that the same construction process can create different representations.（将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561388283844.png" alt=""></p>
<!-- more -->
<h4 id="建造者模式的优点">建造者模式的优点</h4>
<ul>
<li>封装性
使用建造者模式可以使客户端不必知道产品内部组成的细节</li>
<li>建造者独立，容易扩展</li>
<li>便于控制细节风险
由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。</li>
</ul>
<h4 id="建造者模式使用场景">建造者模式使用场景</h4>
<ul>
<li>相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式。</li>
<li>多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时，则可以使用该模式。</li>
<li>产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式非常合适。</li>
<li>在对象创建过程中会使用到系统中的一些其他对象，这些对象在产品对象的创建过程中不易得到时，也可以采用建造者模式封装该对象的创建过程。该种场景只能是一个补偿方法，因为一个对象不容易获得，而在设计阶段竟然没有发觉，而要通过创建者模式柔化创建过程，本身已经违反设计的最初目标。</li>
</ul>
<h4 id="代码实现">代码实现</h4>
<pre><code>public class Product {
     public void doSomething(){
             //独立业务处理
     }
}
public abstract class Builder {    
     //设置产品的不同部分，以获得不同的产品
     public abstract void setPart();
     //建造产品
     public abstract Product buildProduct();
}
public class ConcreteBuilder extends Builder {
     private Product product = new Product();
     //设置产品零件
     public void setPart(){
             /*
              * 产品类内的逻辑处理
              */
     }  
     //组建一个产品
     public Product buildProduct() {
             return product;
     }
}
public class Director {
     private Builder builder = new ConcreteBuilder();
     //构建不同的产品
     public Product getAProduct(){
             builder.setPart();
             /*
              * 设置不同的零件，产生不同的产品
              */
             return builder.buildProduct();
     }
}
</code></pre>
<h4 id="jdk中的建造者模式">JDK中的建造者模式</h4>
<ul>
<li>java.lang.StringBuilder#append() (unsynchronized)</li>
<li>java.lang.StringBuilder#append() (unsynchronized)</li>
<li>java.nio.ByteBuffer#put()(alsoonCharBuffer,ShortBuffer,IntBuffer,LongBuffer,FloatBufferandDoubleBuffer)</li>
<li>javax.swing.GroupLayout.Group#addComponent()</li>
<li>All implementations of java.lang.Appendable</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-模板方法模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-mo-ban-fang-fa-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-mo-ban-fang-fa-mo-shi">
        </link>
        <updated>2019-06-24T14:48:26.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Define the skeleton of an algorithm in an operation,deferring some steps to subclasses.Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.（定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561387763499.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Define the skeleton of an algorithm in an operation,deferring some steps to subclasses.Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.（定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://caijh.github.io//post-images/1561387763499.png" alt=""></p>
<!-- more -->
<h4 id="代码实现">代码实现</h4>
<pre><code>public abstract class AbstractClass {
     //基本方法
     protected abstract void doSomething();
     //基本方法
     protected abstract void doAnything();
     //模板方法
     public void templateMethod(){
             /*
              * 调用基本方法，完成相关的逻辑
              */
             this.doAnything();
             this.doSomething();
     }
}
public class ConcreteClass1 extends AbstractClass {
     //实现基本方法
     protected void doAnything() {
             //业务逻辑处理
     }
     protected void doSomething() {
             //业务逻辑处理
     }
}
public class ConcreteClass2 extends AbstractClass {
     //实现基本方法
     protected void doAnything() {
             //业务逻辑处理
     }
     protected void doSomething() {
             //业务逻辑处理
     }
}
public class Client {
     public static void main(String[] args) {
             AbstractClass class1 = new ConcreteClass1();
             AbstractClass class2 = new ConcreteClass2();               
             //调用模板方法
             class1.templateMethod();
             class2.templateMethod();
     }
}
</code></pre>
<h4 id="模板方法模式的优点">模板方法模式的优点</h4>
<ul>
<li>封装不变部分，扩展可变部分
把认为是不变部分的算法封装到父类实现，而可变部分的则可以通过继承来继续扩展。</li>
<li>提取公共部分代码，便于维护
我们例子中刚刚走过的弯路就是最好的证明，如果我们不抽取到父类中，任由这种散乱的代码发生，想想后果是什么样子？维护人员为了修正一个缺陷，需要到处查找类似的代码！</li>
<li>行为由父类控制，子类实现
基本方法是由子类实现的，因此子类可以通过扩展的方式增加相应的功能，符合开闭原则。</li>
</ul>
<h4 id="模板方法模式的缺点">模板方法模式的缺点</h4>
<p>按照我们的设计习惯，抽象类负责声明最抽象、最一般的事物属性和方法，实现类完成具体的事物属性和方法。但是模板方法模式却颠倒了，抽象类定义了部分抽象方法，由子类实现，子类执行的结果影响了父类的结果，也就是子类对父类产生了影响，这在复杂的项目中，会带来代码阅读的难度，而且也会让新手产生不适感。</p>
<h4 id="模板方法的使用场景">模板方法的使用场景</h4>
<ul>
<li>多个子类有公有的方法，并且逻辑基本相同时。</li>
<li>重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。</li>
<li>重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数（见“模板方法模式的扩展”）约束其行为。</li>
</ul>
<h4 id="jdk中的模板方法模式">JDK中的模板方法模式</h4>
<ul>
<li>java.util.Collections#sort()</li>
<li>java.io.InputStream#skip()</li>
<li>java.io.InputStream#read()</li>
<li>java.util.AbstractList#indexOf()</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-抽象工厂模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-chou-xiang-gong-han-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-chou-xiang-gong-han-mo-shi">
        </link>
        <updated>2019-06-24T14:42:05.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Provide an interface for creating families of related or dependent objects without specifying their concrete classes.（为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。）</p>
</blockquote>
<h4 id="uml类图">UML类图</h4>
<p><img src="https://caijh.github.io//post-images/1561387400624.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Provide an interface for creating families of related or dependent objects without specifying their concrete classes.（为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。）</p>
</blockquote>
<h4 id="uml类图">UML类图</h4>
<p><img src="https://caijh.github.io//post-images/1561387400624.png" alt=""></p>
<!-- more -->
<h4 id="抽象工厂模式的优点">抽象工厂模式的优点：</h4>
<ul>
<li>封装性，每个产品的实现类不是高层模块要关心的，它要关心的是什么？是接口，是抽象，它不关心对象是如何创建出来，这由谁负责呢？工厂类，只要知道工厂类是谁，我就能创建出一个需要的对象，省时省力，优秀设计就应该如此。</li>
<li>产品族内的约束为非公开状态。</li>
</ul>
<h4 id="抽象工厂模式的缺点">抽象工厂模式的缺点：</h4>
<p>抽象工厂模式的最大缺点就是产品族扩展非常困难，为什么这么说呢？我们以通用代码为例，如果要增加一个产品C，也就是说产品家族由原来的2个增加到3个，看看我们的程序有多大改动吧！抽象类AbstractCreator要增加一个方法createProductC()，然后两个实现类都要修改，想想看，这严重违反了开闭原则，而且我们一直说明抽象类和接口是一个契约。改变契约，所有与契约有关系的代码都要修改，那么这段代码叫什么？叫“有毒代码”，——只要与这段代码有关系，就可能产生侵害的危险！</p>
<h4 id="jdk中的抽象工厂模式">JDK中的抽象工厂模式</h4>
<ul>
<li>java.util.Calendar#getInstance()</li>
<li>java.util.Arrays#asList()</li>
<li>java.util.ResourceBundle#getBundle()</li>
<li>java.sql.DriverManager#getConnection()</li>
<li>java.sql.Connection#createStatement()</li>
<li>java.sql.Statement#executeQuery()</li>
<li>java.text.NumberFormat#getInstance()</li>
<li>javax.xml.transform.TransformerFactory#newInstance()</li>
</ul>
<h4 id="代码实现">代码实现</h4>
<pre><code>public abstract class AbstractCreator {
     //创建A产品家族
     public abstract AbstractProductA createProductA(); 
     //创建B产品家族
     public abstract AbstractProductB createProductB();
}

public class Creator1 extends AbstractCreator {    
     //只生产产品等级为1的A产品
     public AbstractProductA createProductA() { 
             return new ProductA1();
     }
     //只生产产品等级为1的B产品
     public AbstractProductB createProductB() {
             return new ProductB1();
     }
}
public class Creator2 extends AbstractCreator {    
     //只生产产品等级为2的A产品
     public AbstractProductA createProductA() { 
             return new ProductA2();
     }
     //只生产产品等级为2的B产品
     public AbstractProductB createProductB() {
             return new ProductB2();
     }
}

public class Client {
     public static void main(String[] args) {
             //定义出两个工厂
             AbstractCreator creator1 = new Creator1();
             AbstractCreator creator2 = new Creator2();
             //产生A1对象
             AbstractProductA a1 =  creator1.createProductA();
             //产生A2对象
             AbstractProductA a2 = creator2.createProductA();
             //产生B1对象
             AbstractProductB b1 = creator1.createProductB();
             //产生B2对象
             AbstractProductB b2 = creator2.createProductB();
             /*
              * 然后在这里就可以为所欲为了...
              */
     }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-工厂方法模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-gong-han-fang-fa-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-gong-han-fang-fa-mo-shi">
        </link>
        <updated>2019-06-24T10:38:35.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Define an interface for creating an object,but let subclasses decide which class to instantiate.Factory Method lets a class defer instantiation to subclasses.（定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/FactoryMethod.jpg" alt="IMAGE"></p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="定义">定义</h4>
<blockquote>
<p>Define an interface for creating an object,but let subclasses decide which class to instantiate.Factory Method lets a class defer instantiation to subclasses.（定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。）</p>
</blockquote>
<h4 id="uml">UML</h4>
<p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/FactoryMethod.jpg" alt="IMAGE"></p>
<!-- more -->
<h4 id="工厂方法模式的优点">工厂方法模式的优点</h4>
<ul>
<li>首先，良好的封装性，代码结构清晰。一个对象创建是有条件约束的，如一个调用者需要一个具体的产品对象，只要知道这个产品的类名（或约束字符串）就可以了，不用知道创建对象的艰辛过程，降低模块间的耦合。</li>
<li>再次，屏蔽产品类。这一特点非常重要，产品类的实现如何变化，调用者都不需要关心，它只需要关心产品的接口，只要接口保持不变，系统中的上层模块就不要发生变化。</li>
<li>最后，工厂方法模式是典型的解耦框架。高层模块值需要知道产品的抽象类，其他的实现类都不用关心，符合迪米特法则，我不需要的就不要去交流；也符合依赖倒置原则，只依赖产品类的抽象；当然也符合里氏替换原则，使用产品子类替换产品父类，没问题！</li>
</ul>
<h4 id="工厂方法模式的使用场景">工厂方法模式的使用场景</h4>
<ul>
<li>工厂方法模式是new一个对象的替代品，所以在所有需要生成对象的地方都可以使用，但是需要慎重地考虑是否要增加一个工厂类进行管理，增加代码的复杂度。</li>
<li>需要灵活的、可扩展的框架时，可以考虑采用工厂方法模式。</li>
<li>工厂方法模式可以用在异构项目中</li>
<li>可以使用在测试驱动开发的框架下</li>
</ul>
<h4 id="jdk中的工厂方法模式">JDK中的工厂方法模式</h4>
<ul>
<li>java.util.Calendar#getInstance()</li>
<li>java.util.ResourceBundle#getBundle()</li>
<li>java.text.NumberFormat#getInstance()</li>
<li>java.nio.charset.Charset#forName()</li>
<li>java.net.URLStreamHandlerFactory#createURLStreamHandler(String) (Returns singleton object per protocol)</li>
</ul>
<h4 id="工厂方法模式代码">工厂方法模式代码</h4>
<pre><code>public abstract class Product {    
     //产品类的公共方法
     public void method1(){
             //业务逻辑处理
     }  
     //抽象方法
     public abstract void method2();    
}

public class ConcreteProduct1 extends Product {
     public void method2() {
             //业务逻辑处理
     }
}
public class ConcreteProduct2 extends Product {
     public void method2() {
             //业务逻辑处理
     }
}

public abstract class Creator {    
     /*
      * 创建一个产品对象，其输入参数类型可以自行设置
      * 通常为String、Enum、Class等，当然也可以为空
      */        
     public abstract &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; c);
}

public class ConcreteCreator extends Creator {     
     public &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; c){
             Product product=null;
             try {
                    product = (Product)Class.forName(c.getName()).newInstance();
             } catch (Exception e) {
                    //异常处理
             }
             return (T)product;         
     }
}

public class ConcreteCreator extends Creator {     
     public &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; c){
             Product product=null;
             try {
                    product = (Product)Class.forName(c.getName()).newInstance();
             } catch (Exception e) {
                    //异常处理
             }
             return (T)product;         
     }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-单例模式]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-dan-li-mo-shi</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-dan-li-mo-shi">
        </link>
        <updated>2019-06-24T09:59:12.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>Ensure a class has only one instance, and provide a global point of access to it.（确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。）</p>
</blockquote>
<h5 id="类图">类图</h5>
<p><img src="https://caijh.github.io//post-images/1561372464381.png" alt=""></p>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>Ensure a class has only one instance, and provide a global point of access to it.（确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。）</p>
</blockquote>
<h5 id="类图">类图</h5>
<p><img src="https://caijh.github.io//post-images/1561372464381.png" alt=""></p>
<!-- more -->
<h6 id="饿汉模式">饿汉模式</h6>
<pre><code>public class Singleton {

    private static final Singleton SINGLETON = new Singleton();

    private Singleton() {

    }

    public static Singleton getInstance() {
        return SINGLETON;
    }
}
</code></pre>
<h6 id="懒汉模式">懒汉模式</h6>
<pre><code>public class SingletonLay {
    private static SingletonLay singletonLay = null;

    private SingletonLay() {

    }

    public static SingletonLay getSingletonLay() {
        if (singletonLay == null) {
            synchronized (SingletonLay.class) {
                if (singletonLay == null) {
                    singletonLay = new SingletonLay();
                }
            }
        }
        return singletonLay;
    }
}
</code></pre>
<p><strong>隐患</strong>
上述写法看似解决了问题，但是有个很大的隐患。实例化对象的那行代码（标记为error的那行），实际上可以分解成以下三个步骤：</p>
<ol>
<li>
<p>分配内存空间</p>
</li>
<li>
<p>初始化对象</p>
</li>
<li>
<p>将对象指向刚分配的内存空间
但是有些编译器为了性能的原因，可能会将第二步和第三步进行重排序，顺序就成了：</p>
</li>
<li>
<p>分配内存空间</p>
</li>
<li>
<p>将对象指向刚分配的内存空间</p>
</li>
<li>
<p>初始化对象</p>
</li>
</ol>
<p>正确的双重检查锁</p>
<pre><code>public class SingletonLay {
    private static volilate SingletonLay singletonLay = null;

    private SingletonLay() {

    }

    public static SingletonLay getSingletonLay() {
        if (singletonLay == null) {
            synchronized (SingletonLay.class) {
                if (singletonLay == null) {
                    singletonLay = new SingletonLay();
                }
            }
        }
        return singletonLay;
    }
}
</code></pre>
<h6 id="enum-方式">Enum 方式</h6>
<pre><code>class Resource{
}

public enum Singleton {
    INSTANCE;
    private Resource instance;
    Singleton() {
        instance = new Resource();
    }
    public Resource getInstance() {
        return instance;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-SOLID原则]]></title>
        <id>https://caijh.github.io//post/she-ji-mo-shi-solid-yuan-ze</id>
        <link href="https://caijh.github.io//post/she-ji-mo-shi-solid-yuan-ze">
        </link>
        <updated>2019-06-24T09:43:42.000Z</updated>
        <summary type="html"><![CDATA[<p>运用设计模式，需要记住六大设计原则：</p>
<ul>
<li>Single Responsibility Principle：单一职责原则</li>
<li>Open Closed Principle：开闭原则</li>
<li>Liskov Substitution Principle：里氏替换原则</li>
<li>Law of Demeter：迪米特法则</li>
<li>Interface Segregation Principle：接口隔离原则</li>
<li>Dependence Inversion Principle：依赖倒置原则</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<p>运用设计模式，需要记住六大设计原则：</p>
<ul>
<li>Single Responsibility Principle：单一职责原则</li>
<li>Open Closed Principle：开闭原则</li>
<li>Liskov Substitution Principle：里氏替换原则</li>
<li>Law of Demeter：迪米特法则</li>
<li>Interface Segregation Principle：接口隔离原则</li>
<li>Dependence Inversion Principle：依赖倒置原则</li>
</ul>
<!-- more -->
<h3 id="单一职责原则">单一职责原则</h3>
<blockquote>
<p>There should never be more than one reason for a class to change.
引起类的变更原因只有一个，类或接口只负责做一件事。
单一职责原则的好处：</p>
</blockquote>
<ul>
<li>类的复杂性降低，实现什么职责都有清晰明确的定义；</li>
<li>可读性提高，复杂性降低，那当然可读性提高了；</li>
<li>可维护性提高，可读性提高，那当然更容易维护了；
变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。
对于接口，我们在设计的时候一定要做到单一，但是对于实现类就需要多方面考虑了。生搬硬套单一职责原则会引起类的剧增，给维护带来非常多的麻烦，而且过分细分类的职责也会人为地增加系统的复杂性。本来一个类可以实现的行为硬要拆成两个类，然后再使用聚合或组合的方式耦合在一起，人为制造了系统的复杂性。</li>
</ul>
<h3 id="开闭原则">开闭原则</h3>
<blockquote>
<p>Software entities like classes,modules and functions should be open for extension but closed for modifications.（一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。）
开闭原则对扩展开放，对修改关闭，并不意味着不做任何修改，低层模块的变更，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段。</p>
</blockquote>
<h4 id="为什么要使用开闭原则">为什么要使用开闭原则？</h4>
<p>开闭原则对测试的影响
开闭原则可以提高复用性
开闭原则可以提高可维护性
开闭原则可以提高可维护性</p>
<h4 id="如何使用开闭原则">如何使用开闭原则？</h4>
<ul>
<li>抽象约束</li>
<li>元数据控制模块行为</li>
<li>制定项目章程，约定优于配置</li>
<li>封装变化，将相同的变化封装到一个接口或抽象类中</li>
</ul>
<h3 id="里氏替换原则">里氏替换原则</h3>
<blockquote>
<p>Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象。）</p>
</blockquote>
<h3 id="迪米特法则">迪米特法则</h3>
<blockquote>
<p>一个对象应该对其他对象有最少的了解。</p>
</blockquote>
<h3 id="接口隔离原则">接口隔离原则</h3>
<blockquote>
<p>Clients should not be forced to depend upon interfaces that they don't use.（客户端不应该依赖它不需要的接口。）
The dependency of one class to another one should depend on the smallest possible interface.（类间的依赖关系应该建立在最小的接口上。）</p>
</blockquote>
<h3 id="依赖倒置原则">依赖倒置原则</h3>
<p>High level modules should not depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions.
翻译过来，包含三层含义：</p>
<ul>
<li>高层模块不应该依赖低层模块，两者都应该依赖其抽象；</li>
<li>抽象不应该依赖细节；</li>
<li>细节应该依赖抽象。</li>
</ul>
]]></content>
    </entry>
</feed>