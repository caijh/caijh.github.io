<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Spring Cloud - Eureka | John&#39;s Blog</title>
<meta name="description" content="搬砖小弟">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="https://caijh.github.io//favicon.ico?v=1572851237552">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://unpkg.com/papercss@1.6.1/dist/paper.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://caijh.github.io//styles/main.css">


  

  
    <link rel="stylesheet" href="https://unpkg.com/disqusjs@1.1/dist/disqusjs.css" />
  

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />


  </head>
  <body>
  
    <nav class="navbar border fixed split-nav">
  <div class="nav-brand">
    <h3><a href="https://caijh.github.io/">John&#39;s Blog</a></h3>
  </div>
  <div class="collapsible">
    <input id="collapsible1" type="checkbox" name="collapsible1">
    <button>
      <label for="collapsible1">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
      </label>
    </button>
    <div class="collapsible-body">
      <ul class="inline">
        
          <li>
            
              <a href="/" class="menu">
                首页
              </a>
            
          </li>
        
          <li>
            
              <a href="/archives" class="menu">
                归档
              </a>
            
          </li>
        
          <li>
            
              <a href="/tags" class="menu">
                标签
              </a>
            
          </li>
        
          <li>
            
              <a href="/post/about" class="menu">
                关于
              </a>
            
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div id="top" class="row site">
      <div class="sm-12 md-8 col">
        <div class="paper">
          <article class="article">
            <h1>Spring Cloud - Eureka</h1>
            <p class="article-meta">
              2019-11-04
              
            </p>
            
            <div class="post-content">
              <blockquote>
<p>是由Netflix开源的基于REST的服务治理组件，包含了eureka server 和eureka client。从2012年9月在GitHub上发布1.1.2版本以来，至今已经发布了231次，最新版本为2018年8月份发布的1.9.4版本。期间有进行2.x版本的开发，不过由于各种原因内部已经冻结开发，目前还是以1.x版本为主。Spring Cloud Netflix Eureka是Pivotal公司为了将Netflix Eureka整合于Spring Cloud生态系统提供的版本。</p>
</blockquote>
<h1 id="eureka快速入门">Eureka快速入门</h1>
<p><strong>Eureka Server</strong></p>
<ol>
<li>
<p>引入依赖</p>
<pre><code>        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>主应用类上添加**@EnableEurekaServer**</p>
</li>
<li>
<p>配置eureka</p>
<pre><code>eureka:
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      defaultZone: ${EUREKA_SERVER_ADDRESS:http://localhost:8761/eureka/}
  server:
    peer-node-read-timeout-ms: 5000
</code></pre>
</li>
<li>
<p>启动</p>
<p>![image-20191024165113212](Spring Cloud - 服务注册中心eureka/image-20191024165113212.png)</p>
</li>
</ol>
<p><strong>Eureka Client</strong></p>
<ol>
<li>
<p>引入客户端依赖</p>
<pre><code>        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>主应用类添加**@EnableDiscoveryClient**</p>
</li>
<li>
<p>配置</p>
<pre><code>eureka:
  instance:
    prefer-ip-address: true
  client:
    service-url:
      defaultZone: ${EUREKA_SERVER_ADDRESS:http://localhost:8761/eureka/}
</code></pre>
</li>
<li>
<p>启动客户端</p>
</li>
</ol>
<!-- more -->
<h1 id="eureka-高可用">Eureka 高可用</h1>
<p>application-peer1.yml</p>
<pre><code>---
server:
  port: 8761

eureka:
  client:
    register-with-eureka: true # 是否向 eureka server 注册
    fetch-registry: true # 是否向 eureka server 获取其他客户端注册信息
    service-url:
      defaultZone: ${EUREKA_SERVER_ADDRESSES:http://localhost:8762/eureka/}
  server:
    registry-sync-retry-wait-ms: 5000

</code></pre>
<p>application-pee2.yml</p>
<pre><code class="language-yaml">---
server:
  port: 8762

eureka:
  client:
    register-with-eureka: true # 是否向 eureka server 注册
    fetch-registry: true # 是否向 eureka server 获取其他客户端注册信息
    service-url:
      defaultZone: ${EUREKA_SERVER_ADDRESSES:http://localhost:8761/eureka/}
  server:
    registry-sync-retry-wait-ms: 5000

</code></pre>
<p>客户端配置</p>
<pre><code class="language-yaml">eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/,http://localhost:8762/eureka/
    register-with-eureka: true
    fetch-registry: true
</code></pre>
<p>启动两个server组成集群，客户配置seviceUrl为集群地址</p>
<ol>
<li>在两个server都没有启动的情况下，启动client会报错，但还是能启动起来的</li>
<li>部分server启动的情况下，client是可以注册到集群的并拉取到服务列表</li>
</ol>
<p>server采用点对点复制方式，高可用主要是在客户端实现的</p>
<ol>
<li>在Client启动之前，如果没有Eureka Server，则可以通过配置eureka.client.backup-registry-impl从备份registry读取关键服务的信息。(一般不会设置，应该是搭建eureka server集群）</li>
<li>在client启动之后，若运行时出现Eureka Server全部挂掉的情况：本地内存有localRegion之前获取的数据，在Eureka Server都不可用的情况下，从Server端定时拉取注册信息回来更新的线程CacheRefreshThread会执行失败，本地localRegion信息不会被更新。</li>
<li>Client端维护了一个Eureka Server的不可用列表，一旦请求发生Connection error或者5xx的情况则会被列入该列表，当该列表的大小超过指定阈值则会重新清空。在重新清空的情况下，Client默认是采用RetryableEurekaHttpClient进行请求，numberOfRetries为3，因此也能够在一定程度保障Client的高可用。</li>
</ol>
<h1 id="eureka-设计原理">Eureka 设计原理</h1>
<p>作为服务注册中心，主要解决以下问题：</p>
<ol>
<li>
<p>客户端怎么向服务注册中心注册？</p>
<p>服务启动时，调用Eureka Server的REST API的register方法，去注册该应用实例的信息。</p>
</li>
<li>
<p>服务实例怎么从服务注册中心中剔除</p>
<p>正常情况下，服务在关闭时通过钩子方法或其他生命周期回调方法去调用Eureka Server的REST API的de-register方法，来删除自身服务实例的信息。为了解决异常情况下，服务没有及时从服务中剔除，Eureka Server要求客户端每隔一段时间续约，发送心跳。如果租约超过一定时间没有进行续约操作，Eureka Server端会主动剔除服务。</p>
</li>
<li>
<p>服务实例数据的一致性问题</p>
<p>服务注册中心微服务中重要的组件，在生产环境中必然是集群部署，两个服务注册中心上的服务列表数据怎么保持一致呢？</p>
<p>下面从四个方面来解释：</p>
<ul>
<li>
<p>AP优于CP</p>
<p>对于分布式系统来说，一般网络条件相对不可控，出现网络分区是不可避免的，因此系统必须具备分区容忍性。在这个前提下分布式系统的设计则在AP及CP之间进行选择。Eureka是在部署在AWS的背景下设计的，其设计者认为，在云端，特别是在大规模部署的情况下，失败是不可避免的，可能因为Eureka自身部署失败，注册的服务不可用，或者由于网络分区导致服务不可用，因此不能回避这个问题。要拥抱这个问题，就需要Eureka在网络分区的时候，还能够正常提供服务注册及发现功能，因此Eureka选择满足Availability这个特性。在实际生产实践中，服务注册及发现中心保留可用及过期的数据总比丢失掉可用的数据好。</p>
</li>
<li>
<p>Peer to Peer</p>
<p>Eureka Server本身依赖了Eureka Client，也就是每个Eureka Server是作为其他Eureka Server的Client。在单个Eureka Server启动的时候，会有一个syncUp的操作，通过Eureka Client请求其他Eureka Server节点中的一个节点获取注册的应用实例信息，然后复制到其他peer节点。</p>
<p>Eureka Server在执行复制操作的时候，使用HEADER_REPLICATION的http header来将这个请求操作与普通应用实例的正常请求操作区分开来。通过HEADER_REPLICATION来标识是复制请求，这样其他peer节点接收到请求的时候，就不会再对它的peer节点进行复制操作，从而避免死循环。</p>
</li>
<li>
<p>Region及Zone设计</p>
<p>由于Netflix的服务大部分是部署在amazon上，因此Eureka的设计一部分也是基于zmazon的region及zone的基础设施上。</p>
<p>Region可以理解为地理上的分区，如亚洲地区、华北地区；Zone可以理解为region内的具体机房，比如说 region 划分为华北地区，然后华北地区有两个机房，就可以在此 region 之下划分出 zone1、zone2 两个 zone。服务最好是注册到同一zone的注册中心，因为如果不是同一zone,可能心跳检测有会问题。服务调用是优先调用同一zone的服务的。</p>
<p>Eureka Server原生支持了Region及AvailabilityZone，由于资源在Region之间默认是不会复制的，因此Eureka Server的高可用主要就在于Region下面的AvailabilityZone。</p>
<p>Eureka Client支持preferSameZone，也就是获取Eureka Server的serviceUrl优先拉取跟应用实例同处于一个AvailabilityZone的Eureka Server地址列表。一个AvailabilityZone可以设置多个Eureka Server实例，它们之间构成peer节点，然后采用Peer to Peer的复制模式。</p>
</li>
<li>
<p>自我保护模式</p>
<p>在分布式系统中通常是要对服务实例进行存活检测的，在发生网络抖动或暂时不可用时可能会误判， 极端情况可能造成注册中心清空服务列表。因此Eureka使用保护模式。</p>
<p>Eureka Client端与Server端之间有个租约，Client要定时发送心跳来维持这个租约，表示自己还存活着。Eureka通过当前注册的实例数，去计算每分钟应该从应用实例接收到的心跳数，如果最近一分钟接收到的续约的次数小于等于指定阈值的话，则关闭租约失效剔除，禁止定时任务剔除失效的实例，从而保护注册信息。</p>
<p>关闭自我保护模样:<code>eureka.server.enable-self-preservation=true</code></p>
</li>
</ul>
</li>
</ol>
<h1 id="eureka-核心类">Eureka 核心类</h1>
<p><strong>InstanceInfo</strong></p>
<p>Eureka使用InstanceInfo类代表注册的服务实例。其主要字段有：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>instanceId</td>
<td>实例id</td>
</tr>
<tr>
<td>appName</td>
<td>应用名</td>
</tr>
<tr>
<td>ipAddr</td>
<td>服务的ip地址</td>
</tr>
<tr>
<td>port</td>
<td>端口</td>
</tr>
<tr>
<td>datacenterInfo</td>
<td>DataCenterInfo（Netflix, Amazon, MyOwn）</td>
</tr>
<tr>
<td>leaseInfo</td>
<td>LeaseInfo租约信息</td>
</tr>
<tr>
<td>Status</td>
<td>InstanceStatus服务实例信息</td>
</tr>
<tr>
<td>lastUpdatedTimestamp</td>
<td>上一次更新时间</td>
</tr>
<tr>
<td>lastDirtyTimestamp</td>
<td>上一次失效时间</td>
</tr>
<tr>
<td>metadata</td>
<td>元数据信息</td>
</tr>
</tbody>
</table>
<p><strong>LeaseInfo</strong></p>
<p>Eureka使用LeaseInfo表示应用服务实例的租约信息，其主要字段有：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>serviceUpTimestamp</td>
<td>服务启动的时间戳</td>
</tr>
<tr>
<td>registrationTimestamp</td>
<td>服务注册的时间戳</td>
</tr>
<tr>
<td>lastRenewalTimestamp</td>
<td>上一次续租时间戳</td>
</tr>
<tr>
<td>evictionTimestamp</td>
<td>被剔除的时间戳</td>
</tr>
<tr>
<td>renewalIntervalInSecs</td>
<td>客户端续租的间隔周期</td>
</tr>
<tr>
<td>durationInSecs</td>
<td>客户端设置的租约的有效时长</td>
</tr>
</tbody>
</table>
<p><strong>InstanceStatus</strong></p>
<p>Eureka使用InstanceStatus表示服务实例的状态。InstanceStatus是枚举类，枚举值有：</p>
<table>
<thead>
<tr>
<th>UP</th>
<th>服务上线</th>
</tr>
</thead>
<tbody>
<tr>
<td>DOWN</td>
<td>服务下线（心跳检测失败）</td>
</tr>
<tr>
<td>STARTING</td>
<td>服务启动中</td>
</tr>
<tr>
<td>OUT_OF_SERVICE</td>
<td>服务关闭（服务自己下线）</td>
</tr>
<tr>
<td>UNKNOWN</td>
<td>未知</td>
</tr>
</tbody>
</table>
<p><strong>ServiceInstance</strong></p>
<p>ServiceInstance是Spring Cloud是service discovery的实例的抽象接口，约定的服务的实例应该有哪些通用信息。由于Spring Cloud Discovery适配了Zookeeper、Consul、Netflix Eureka等注册中心，因此其ServiceInstance定义更为抽象和通用，而且采取的是定义方法的方式。EurekaRegistration实现了ServiceInstance接口。</p>
<p><strong>LeaseManager</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>void register(T r, int leaseDuration, boolean isReplication)</td>
<td>注册新服务</td>
</tr>
<tr>
<td>boolean cancel(String appName, String id, boolean isReplication)</td>
<td>删除服务</td>
</tr>
<tr>
<td>boolean renew(String appName, String id, boolean isReplication)</td>
<td>服务续约</td>
</tr>
<tr>
<td>void evict()</td>
<td>剔除过期的服务，server使用</td>
</tr>
</tbody>
</table>
<p><strong>LookupService</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Application getApplication(String appName);</td>
<td>根据appName查找应用</td>
</tr>
<tr>
<td>Applications getApplications();</td>
<td>查询所有应用</td>
</tr>
<tr>
<td>List<InstanceInfo> getInstancesById(String id);</td>
<td>根据id查找服务实例</td>
</tr>
<tr>
<td>InstanceInfo getNextServerFromEureka(String virtualHostname, boolean secure);</td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="eureka-核心参数">Eureka 核心参数</h1>
<p><strong>Server与Client共用参数</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>eureka.instance.instanceId</td>
<td></td>
<td>eureka实例id</td>
</tr>
<tr>
<td>eureka.instance.preferIpAddress</td>
<td>flase</td>
<td>是否优先使用ip来代替hostname作为实例的hostName字段的值</td>
</tr>
<tr>
<td>eureka.instance.metadataMap</td>
<td></td>
<td>eureka实例的元数据</td>
</tr>
<tr>
<td>eureka.instance.leaseRenewalIntervalInSeconds</td>
<td>30</td>
<td>eureka client发送心跳的周期</td>
</tr>
<tr>
<td>eureka.instance.leaseExpirationDurationInSeconds</td>
<td>90</td>
<td>eureka server等待client续约的时间</td>
</tr>
</tbody>
</table>
<p>更多参数见<strong>EurekaInstanceConfigBean</strong></p>
<p><strong>Server端(见EurekaServerConfigBean)</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>eureka.server.enableSelfPreservation</td>
<td>True</td>
<td>是否启用保护模式</td>
</tr>
<tr>
<td>eureka.server.renewalPercentThreshold</td>
<td>0.85</td>
<td>指定需要收到续租的阀值</td>
</tr>
<tr>
<td>eureka.server.renewalThresholdUpdateIntervalMs</td>
<td>15分钟</td>
<td>指定了renewalThresholdUpdate定时任务的调度频率</td>
</tr>
<tr>
<td>eureka.server.evictionIntervalTimerInMs</td>
<td>60 * 1000</td>
<td>指定了EvictionTask的调度频率，用于剔除过期的服务</td>
</tr>
<tr>
<td>eureka.server.useReadOnlyResponseCache</td>
<td>True</td>
<td>是否使用只读的response cache</td>
</tr>
<tr>
<td>eureka.server.responseCacheUpdateIntervalMs</td>
<td>30s</td>
<td>设置CacheUpdateTask的调度时间间隔</td>
</tr>
<tr>
<td>eureka.server.responseCacheAutoExpirationInSeconds</td>
<td></td>
<td>readWriteCacheMapr的expireAfterWrite，指定写入多常时间过期</td>
</tr>
<tr>
<td>eureka.server.peerEurekaNodesUpdateIntervalMs</td>
<td>10分钟</td>
<td>指定PeerUpdateTask的时间间隔</td>
</tr>
<tr>
<td>eureka.server.peerEurekaStatusRefreshTimeIntervalMs</td>
<td>30s</td>
<td>指定更新peer状态的时间隔</td>
</tr>
<tr>
<td>eureka.server.peerNodeConnectTimeoutMs</td>
<td>200ms</td>
<td>peer节点连接超时,单位ms</td>
</tr>
<tr>
<td>eureka.server.peerNodeReadTimeoutMs</td>
<td>200ms</td>
<td>peer节点读超时</td>
</tr>
<tr>
<td>eureka.server.peerNodeTotalConnections</td>
<td>1000</td>
<td>连接池最大连接数</td>
</tr>
</tbody>
</table>
<p>更多配置见于<strong>EurekaServerConfigBean</strong></p>
<p><strong>Client端</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>eureka.client.availabilityZones</td>
<td></td>
<td>告知client有哪些region及zone</td>
</tr>
<tr>
<td>eureka.client.region</td>
<td>us-east-1</td>
<td>指定该实例所在的region</td>
</tr>
<tr>
<td>eureka.client.registerWithEureka</td>
<td>true</td>
<td>是否向eureka server注册</td>
</tr>
<tr>
<td>eureka.client.preferSameZoneEureka</td>
<td>true</td>
<td>是否优先向同一zone的server注册或者拉取服务列表信息</td>
</tr>
<tr>
<td>eureka.client.filterOnlyUpInstances</td>
<td>true</td>
<td>是否过滤出InstanceStatus为UP的服务实例</td>
</tr>
<tr>
<td>eureka.client.serviceUrl</td>
<td></td>
<td>eureka server 的地址</td>
</tr>
<tr>
<td>eureka.client.eurekaServerReadTimeoutSeconds</td>
<td>8s</td>
<td>读超时时间</td>
</tr>
<tr>
<td>eureka.client.eurekaServerConnectTimeoutSeconds</td>
<td>5s</td>
<td>连接eureka server的超时时间</td>
</tr>
<tr>
<td>eureka.instance.metadataMap</td>
<td></td>
<td>eureka 实例的元数据信息</td>
</tr>
</tbody>
</table>
<p>更多配置见于<strong>EurekaClientConfigBean</strong></p>
<h1 id="eureka-rest端点">Eureka REST端点</h1>
<p><strong>appID</strong>: 应用名称</p>
<p><strong>instanceID</strong>：应用实例的id</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>Http action</th>
</tr>
</thead>
<tbody>
<tr>
<td>服务注册</td>
<td>POST /eureka/apps/<strong>appID</strong></td>
</tr>
<tr>
<td>服务下线</td>
<td>DELETE /eureka/apps/<strong>appID</strong>/<strong>instanceID</strong></td>
</tr>
<tr>
<td>发送心跳</td>
<td>PUT /eureka/apps/<strong>appID</strong>/<strong>instanceID</strong></td>
</tr>
<tr>
<td>查询所有appId的实例</td>
<td>GET /eureka/apps/<strong>appID</strong></td>
</tr>
<tr>
<td>查询 实例的信息</td>
<td>GET /eureka/apps/<strong>appID</strong>/<strong>instanceID</strong></td>
</tr>
</tbody>
</table>
<p>更多见https://github.com/Netflix/eureka/wiki/Eureka-REST-operations</p>
<p>调用endpoint一个例子：</p>
<figure data-type="image" tabindex="1"><img src="https://caijh.github.io//post-images/1572851163698.png" alt=""></figure>
<h1 id="eureka-源码">Eureka 源码</h1>
<h2 id="server端"><strong>Server端</strong></h2>
<h3 id="启动过程"><strong>启动过程</strong></h3>
<ol>
<li>
<p>注解@EnableEurekaServer引入EurekaServerMarkerConfiguration，EurekaServerMarkerConfiguration中生成一个名为Maker的Bean，其作用是EurekaServerAutoConfiguration生效</p>
</li>
<li>
<p>EurekaServerAutoConfiguration中又引入了EurekaServerInitializerConfiguration配置，EurekaServerInitializerConfiguration中的start方法启动了eureka server</p>
<pre><code class="language-java">@Override
public void start() {
   new Thread(new Runnable() {
      @Override
      public void run() {
         try {
            // TODO: is this class even needed now?
            eurekaServerBootstrap.contextInitialized(
                  EurekaServerInitializerConfiguration.this.servletContext);
            log.info(&quot;Started Eureka Server&quot;);

            publish(new EurekaRegistryAvailableEvent(getEurekaServerConfig()));
            EurekaServerInitializerConfiguration.this.running = true;
            publish(new EurekaServerStartedEvent(getEurekaServerConfig()));
         }
         catch (Exception ex) {
            // Help!
            log.error(&quot;Could not initialize Eureka servlet context&quot;, ex);
         }
      }
   }).start();
}
</code></pre>
</li>
<li>
<p>eurekaServerBootstrap.contextInitialized中完成初始化eureka环境变量，eureka上下文</p>
<pre><code class="language-java">public void contextInitialized(ServletContext context) {
   try {
      initEurekaEnvironment();
      initEurekaServerContext();

      context.setAttribute(EurekaServerContext.class.getName(), this.serverContext);
   }
   catch (Throwable e) {
      log.error(&quot;Cannot bootstrap eureka server :&quot;, e);
      throw new RuntimeException(&quot;Cannot bootstrap eureka server :&quot;, e);
   }
}

</code></pre>
</li>
<li>
<p>initEurekaServerContext启动Eureka Server</p>
<pre><code class="language-java">protected void initEurekaServerContext() throws Exception {
   // For backward compatibility
   JsonXStream.getInstance().registerConverter(new V1AwareInstanceInfoConverter(),
         XStream.PRIORITY_VERY_HIGH);
   XmlXStream.getInstance().registerConverter(new V1AwareInstanceInfoConverter(),
         XStream.PRIORITY_VERY_HIGH);

   if (isAws(this.applicationInfoManager.getInfo())) {
      this.awsBinder = new AwsBinderDelegate(this.eurekaServerConfig,
            this.eurekaClientConfig, this.registry, this.applicationInfoManager);
      this.awsBinder.start();
   }

   EurekaServerContextHolder.initialize(this.serverContext);

   log.info(&quot;Initialized server context&quot;);

   // Copy registry from neighboring eureka node
   int registryCount = this.registry.syncUp();  // 拉取服务信息
   this.registry.openForTraffic(this.applicationInfoManager, registryCount);

   // Register all monitoring statistics.
   EurekaMonitors.registerAllStats();
}
</code></pre>
</li>
</ol>
<h3 id="剔除服务"><strong>剔除服务</strong></h3>
<p>server端剔除服务实例是由一个位于AbstractInstanceRegistry中名为evictionTimer的Timer定时器来执行EvictionTask任务。</p>
<pre><code class="language-java">public void evict(long additionalLeaseMs) {
    logger.debug(&quot;Running the evict task&quot;);

    if (!isLeaseExpirationEnabled()) {
        logger.debug(&quot;DS: lease expiration is currently disabled.&quot;);
        return;
    }

    // We collect first all expired items, to evict them in random order. For large eviction sets,
    // if we do not that, we might wipe out whole apps before self preservation kicks in. By randomizing it,
    // the impact should be evenly distributed across all applications.
    List&lt;Lease&lt;InstanceInfo&gt;&gt; expiredLeases = new ArrayList&lt;&gt;();
    for (Entry&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; groupEntry : registry.entrySet()) {
        Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; leaseMap = groupEntry.getValue();
        if (leaseMap != null) {
            for (Entry&lt;String, Lease&lt;InstanceInfo&gt;&gt; leaseEntry : leaseMap.entrySet()) {
                Lease&lt;InstanceInfo&gt; lease = leaseEntry.getValue();
                if (lease.isExpired(additionalLeaseMs) &amp;&amp; lease.getHolder() != null) {
                    expiredLeases.add(lease);
                }
            }
        }
    }

    // To compensate for GC pauses or drifting local time, we need to use current registry size as a base for
    // triggering self-preservation. Without that we would wipe out full registry.
    int registrySize = (int) getLocalRegistrySize();
    int registrySizeThreshold = (int) (registrySize * serverConfig.getRenewalPercentThreshold());
    int evictionLimit = registrySize - registrySizeThreshold;

    int toEvict = Math.min(expiredLeases.size(), evictionLimit);
    if (toEvict &gt; 0) {
        logger.info(&quot;Evicting {} items (expired={}, evictionLimit={})&quot;, toEvict, expiredLeases.size(), evictionLimit);

        Random random = new Random(System.currentTimeMillis());
        for (int i = 0; i &lt; toEvict; i++) {
            // Pick a random item (Knuth shuffle algorithm)
            int next = i + random.nextInt(expiredLeases.size() - i);
            Collections.swap(expiredLeases, i, next);
            Lease&lt;InstanceInfo&gt; lease = expiredLeases.get(i);

            String appName = lease.getHolder().getAppName();
            String id = lease.getHolder().getId();
            EXPIRED.increment();
            logger.warn(&quot;DS: Registry: expired lease for {}/{}&quot;, appName, id);
            internalCancel(appName, id, false); // 注销服务实例
        }
    }
}
</code></pre>
<h2 id="client端">Client端</h2>
<h3 id="服务注册">服务注册</h3>
<ol>
<li>
<p>从EnableDiscoveryClient注解开始</p>
<p>由注解@EnableDiscoveryClient引入AutoServiceRegistrationConfiguration，AutoServiceRegistrationConfiguration开启通过配置spring.cloud.service-registry.auto-registration.enabled，并创建Marker Bean实例</p>
</li>
<li>
<p>EurekaClientAutoConfiguration类创建EurekaAutoServiceRegistration Bean</p>
<pre><code class="language-java">@Bean
@ConditionalOnBean(AutoServiceRegistrationProperties.class)
@ConditionalOnProperty(value = &quot;spring.cloud.service-registry.auto-registration.enabled&quot;, matchIfMissing = true)
public EurekaAutoServiceRegistration eurekaAutoServiceRegistration(
      ApplicationContext context, EurekaServiceRegistry registry,
      EurekaRegistration registration) {
   return new EurekaAutoServiceRegistration(context, registry, registration);
}

</code></pre>
<p>EurekaAutoServiceRegistration是实现了<strong>SmartLifecycle</strong>接口，start方法完成初始化</p>
<pre><code class="language-java">@Override
public void start() {
   // only set the port if the nonSecurePort or securePort is 0 and this.port != 0
   if (this.port.get() != 0) {
      if (this.registration.getNonSecurePort() == 0) {
         this.registration.setNonSecurePort(this.port.get());
      }

      if (this.registration.getSecurePort() == 0 &amp;&amp; this.registration.isSecure()) {
         this.registration.setSecurePort(this.port.get());
      }
   }

   // only initialize if nonSecurePort is greater than 0 and it isn't already running
   // because of containerPortInitializer below
   if (!this.running.get() &amp;&amp; this.registration.getNonSecurePort() &gt; 0) {

      this.serviceRegistry.register(this.registration); // 实际上没有注册，只是get信息

      this.context.publishEvent(new InstanceRegisteredEvent&lt;&gt;(this,
            this.registration.getInstanceConfig()));
      this.running.set(true);
   }
}

</code></pre>
</li>
<li>
<p>CloudEurekaClient的初始化</p>
<pre><code class="language-java">@Bean(destroyMethod = &quot;shutdown&quot;)
@ConditionalOnMissingBean(value = EurekaClient.class, search = SearchStrategy.CURRENT)
public EurekaClient eurekaClient(ApplicationInfoManager manager,
      EurekaClientConfig config) {
   return new CloudEurekaClient(manager, config, this.optionalArgs,
         this.context);
}

</code></pre>
<pre><code class="language-java">@Inject
DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,
                Provider&lt;BackupRegistry&gt; backupRegistryProvider, EndpointRandomizer endpointRandomizer) {
    if (args != null) {
        this.healthCheckHandlerProvider = args.healthCheckHandlerProvider;
        this.healthCheckCallbackProvider = args.healthCheckCallbackProvider;
        this.eventListeners.addAll(args.getEventListeners());
        this.preRegistrationHandler = args.preRegistrationHandler;
    } else {
        this.healthCheckCallbackProvider = null;
        this.healthCheckHandlerProvider = null;
        this.preRegistrationHandler = null;
    }
    
    this.applicationInfoManager = applicationInfoManager;
    InstanceInfo myInfo = applicationInfoManager.getInfo();

    clientConfig = config;
    staticClientConfig = clientConfig;
    transportConfig = config.getTransportConfig();
    instanceInfo = myInfo;
    if (myInfo != null) {
        appPathIdentifier = instanceInfo.getAppName() + &quot;/&quot; + instanceInfo.getId();
    } else {
        logger.warn(&quot;Setting instanceInfo to a passed in null value&quot;);
    }

    this.backupRegistryProvider = backupRegistryProvider;
    this.endpointRandomizer = endpointRandomizer;
    this.urlRandomizer = new EndpointUtils.InstanceInfoBasedUrlRandomizer(instanceInfo);
    localRegionApps.set(new Applications());

    fetchRegistryGeneration = new AtomicLong(0);

    remoteRegionsToFetch = new AtomicReference&lt;String&gt;(clientConfig.fetchRegistryForRemoteRegions());
    remoteRegionsRef = new AtomicReference&lt;&gt;(remoteRegionsToFetch.get() == null ? null : remoteRegionsToFetch.get().split(&quot;,&quot;));

    if (config.shouldFetchRegistry()) {
        this.registryStalenessMonitor = new ThresholdLevelsMetric(this, METRIC_REGISTRY_PREFIX + &quot;lastUpdateSec_&quot;, new long[]{15L, 30L, 60L, 120L, 240L, 480L});
    } else {
        this.registryStalenessMonitor = ThresholdLevelsMetric.NO_OP_METRIC;
    }

    if (config.shouldRegisterWithEureka()) {
        this.heartbeatStalenessMonitor = new ThresholdLevelsMetric(this, METRIC_REGISTRATION_PREFIX + &quot;lastHeartbeatSec_&quot;, new long[]{15L, 30L, 60L, 120L, 240L, 480L});
    } else {
        this.heartbeatStalenessMonitor = ThresholdLevelsMetric.NO_OP_METRIC;
    }

    logger.info(&quot;Initializing Eureka in region {}&quot;, clientConfig.getRegion());

    if (!config.shouldRegisterWithEureka() &amp;&amp; !config.shouldFetchRegistry()) {
        logger.info(&quot;Client configured to neither register nor query for data.&quot;);
        scheduler = null;
        heartbeatExecutor = null;
        cacheRefreshExecutor = null;
        eurekaTransport = null;
        instanceRegionChecker = new InstanceRegionChecker(new PropertyBasedAzToRegionMapper(config), clientConfig.getRegion());

        // This is a bit of hack to allow for existing code using DiscoveryManager.getInstance()
        // to work with DI'd DiscoveryClient
        DiscoveryManager.getInstance().setDiscoveryClient(this);
        DiscoveryManager.getInstance().setEurekaClientConfig(config);

        initTimestampMs = System.currentTimeMillis();
        logger.info(&quot;Discovery Client initialized at timestamp {} with initial instances count: {}&quot;,
                initTimestampMs, this.getApplications().size());

        return;  // no need to setup up an network tasks and we are done
    }

    try {
        // default size of 2 - 1 each for heartbeat and cacheRefresh
        scheduler = Executors.newScheduledThreadPool(2,
                new ThreadFactoryBuilder()
                        .setNameFormat(&quot;DiscoveryClient-%d&quot;)
                        .setDaemon(true)
                        .build());

        heartbeatExecutor = new ThreadPoolExecutor(
                1, clientConfig.getHeartbeatExecutorThreadPoolSize(), 0, TimeUnit.SECONDS,
                new SynchronousQueue&lt;Runnable&gt;(),
                new ThreadFactoryBuilder()
                        .setNameFormat(&quot;DiscoveryClient-HeartbeatExecutor-%d&quot;)
                        .setDaemon(true)
                        .build()
        );  // use direct handoff

        cacheRefreshExecutor = new ThreadPoolExecutor(
                1, clientConfig.getCacheRefreshExecutorThreadPoolSize(), 0, TimeUnit.SECONDS,
                new SynchronousQueue&lt;Runnable&gt;(),
                new ThreadFactoryBuilder()
                        .setNameFormat(&quot;DiscoveryClient-CacheRefreshExecutor-%d&quot;)
                        .setDaemon(true)
                        .build()
        );  // use direct handoff

        eurekaTransport = new EurekaTransport();
        scheduleServerEndpointTask(eurekaTransport, args); // 准备访问eureka server的客户端

        AzToRegionMapper azToRegionMapper;
        if (clientConfig.shouldUseDnsForFetchingServiceUrls()) {
            azToRegionMapper = new DNSBasedAzToRegionMapper(clientConfig);
        } else {
            azToRegionMapper = new PropertyBasedAzToRegionMapper(clientConfig);
        }
        if (null != remoteRegionsToFetch.get()) {
            azToRegionMapper.setRegionsToFetch(remoteRegionsToFetch.get().split(&quot;,&quot;));
        }
        instanceRegionChecker = new InstanceRegionChecker(azToRegionMapper, clientConfig.getRegion());
    } catch (Throwable e) {
        throw new RuntimeException(&quot;Failed to initialize DiscoveryClient!&quot;, e);
    }

    if (clientConfig.shouldFetchRegistry() &amp;&amp; !fetchRegistry(false)) { // 获取已经注册的服务
        fetchRegistryFromBackup();
    }

    // call and execute the pre registration handler before all background tasks (inc registration) is started
    if (this.preRegistrationHandler != null) {
        this.preRegistrationHandler.beforeRegistration();
    }

    if (clientConfig.shouldRegisterWithEureka() &amp;&amp; clientConfig.shouldEnforceRegistrationAtInit()) {
        try {
            if (!register() ) { // 如果是否在初始始化时向Eureka Server注册
                throw new IllegalStateException(&quot;Registration error at startup. Invalid server response.&quot;);
            }
        } catch (Throwable th) {
            logger.error(&quot;Registration error at startup: {}&quot;, th.getMessage());
            throw new IllegalStateException(th);
        }
    }

    // finally, init the schedule tasks (e.g. cluster resolvers, heartbeat, instanceInfo replicator, fetch
    initScheduledTasks();  // 初始化定时任务

    try {
        Monitors.registerObject(this);
    } catch (Throwable e) {
        logger.warn(&quot;Cannot register timers&quot;, e);
    }

    // This is a bit of hack to allow for existing code using DiscoveryManager.getInstance()
    // to work with DI'd DiscoveryClient
    DiscoveryManager.getInstance().setDiscoveryClient(this);
    DiscoveryManager.getInstance().setEurekaClientConfig(config);

    initTimestampMs = System.currentTimeMillis();
    logger.info(&quot;Discovery Client initialized at timestamp {} with initial instances count: {}&quot;,
            initTimestampMs, this.getApplications().size());
}
</code></pre>
</li>
<li>
<p>向eureka server注册是由instanceInfoReplicator的start方法，这时默认延迟40s注册</p>
<pre><code class="language-java">/**
 * Register with the eureka service by making the appropriate REST call.
 */
boolean register() throws Throwable {
    logger.info(PREFIX + &quot;{}: registering service...&quot;, appPathIdentifier);
    EurekaHttpResponse&lt;Void&gt; httpResponse;
    try {
        httpResponse = eurekaTransport.registrationClient.register(instanceInfo);
    } catch (Exception e) {
        logger.warn(PREFIX + &quot;{} - registration failed {}&quot;, appPathIdentifier, e.getMessage(), e);
        throw e;
    }
    if (logger.isInfoEnabled()) {
        logger.info(PREFIX + &quot;{} - registration status: {}&quot;, appPathIdentifier, httpResponse.getStatusCode());
    }
    return httpResponse.getStatusCode() == Status.NO_CONTENT.getStatusCode();
}
</code></pre>
<pre><code>@Override
public EurekaHttpResponse&lt;Void&gt; register(InstanceInfo info) {
    String urlPath = &quot;apps/&quot; + info.getAppName();
    ClientResponse response = null;
    try {
        Builder resourceBuilder = jerseyClient.resource(serviceUrl).path(urlPath).getRequestBuilder();
        addExtraHeaders(resourceBuilder);
        response = resourceBuilder
                .header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;)
                .type(MediaType.APPLICATION_JSON_TYPE)
                .accept(MediaType.APPLICATION_JSON)
                .post(ClientResponse.class, info);
        return anEurekaHttpResponse(response.getStatus()).headers(headersOf(response)).build();
    } finally {
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Jersey HTTP POST {}/{} with instance {}; statusCode={}&quot;, serviceUrl, urlPath, info.getId(),
                    response == null ? &quot;N/A&quot; : response.getStatus());
        }
        if (response != null) {
            response.close();
        }
    }
}
</code></pre>
</li>
</ol>
<h3 id="服务续约">服务续约</h3>
<p>心跳检测执行器heartbeatExecutor会定时执行线程HeartbeatThread，会执行renew向eureka server续租</p>
<pre><code class="language-java">/**
 * Renew with the eureka service by making the appropriate REST call
 */
boolean renew() {
    EurekaHttpResponse&lt;InstanceInfo&gt; httpResponse;
    try {
        httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, null);
        logger.debug(PREFIX + &quot;{} - Heartbeat status: {}&quot;, appPathIdentifier, httpResponse.getStatusCode());
        if (httpResponse.getStatusCode() == Status.NOT_FOUND.getStatusCode()) {
            REREGISTER_COUNTER.increment();
            logger.info(PREFIX + &quot;{} - Re-registering apps/{}&quot;, appPathIdentifier, instanceInfo.getAppName());
            long timestamp = instanceInfo.setIsDirtyWithTime();
            boolean success = register();
            if (success) {
                instanceInfo.unsetIsDirty(timestamp);
            }
            return success;
        }
        return httpResponse.getStatusCode() == Status.OK.getStatusCode();
    } catch (Throwable e) {
        logger.error(PREFIX + &quot;{} - was unable to send heartbeat!&quot;, appPathIdentifier, e);
        return false;
    }
}
</code></pre>
<h3 id="服务下线">服务下线</h3>
<pre><code class="language-java">@PreDestroy
@Override
public synchronized void shutdown() {
    if (isShutdown.compareAndSet(false, true)) {
        logger.info(&quot;Shutting down DiscoveryClient ...&quot;);

        if (statusChangeListener != null &amp;&amp; applicationInfoManager != null) {
            applicationInfoManager.unregisterStatusChangeListener(statusChangeListener.getId());
        }

        cancelScheduledTasks();

        // If APPINFO was registered
        if (applicationInfoManager != null
                &amp;&amp; clientConfig.shouldRegisterWithEureka()
                &amp;&amp; clientConfig.shouldUnregisterOnShutdown()) {
            applicationInfoManager.setInstanceStatus(InstanceStatus.DOWN);
            unregister();
        }

        if (eurekaTransport != null) {
            eurekaTransport.shutdown();
        }

        heartbeatStalenessMonitor.shutdown();
        registryStalenessMonitor.shutdown();

        logger.info(&quot;Completed shut down of DiscoveryClient&quot;);
    }
}
</code></pre>
<h3 id="更新服务列表">更新服务列表</h3>
<p>默认每隔30s从服务端GET一次增量版本信息，然后和本地比较并合并，保证本地能获取到其他节点最新注册信息。</p>
<p>TimedSupervisorTask每隔30s执行CacheRefreshThread线程</p>
<pre><code class="language-java">class CacheRefreshThread implements Runnable {
    public void run() {
        refreshRegistry();
    }
}

@VisibleForTesting
void refreshRegistry() {
    try {
        boolean isFetchingRemoteRegionRegistries = isFetchingRemoteRegionRegistries();

        boolean remoteRegionsModified = false;
        // This makes sure that a dynamic change to remote regions to fetch is honored.
        String latestRemoteRegions = clientConfig.fetchRegistryForRemoteRegions();
        if (null != latestRemoteRegions) {
            String currentRemoteRegions = remoteRegionsToFetch.get();
            if (!latestRemoteRegions.equals(currentRemoteRegions)) {
                // Both remoteRegionsToFetch and AzToRegionMapper.regionsToFetch need to be in sync
                synchronized (instanceRegionChecker.getAzToRegionMapper()) {
                    if (remoteRegionsToFetch.compareAndSet(currentRemoteRegions, latestRemoteRegions)) {
                        String[] remoteRegions = latestRemoteRegions.split(&quot;,&quot;);
                        remoteRegionsRef.set(remoteRegions);
                        instanceRegionChecker.getAzToRegionMapper().setRegionsToFetch(remoteRegions);
                        remoteRegionsModified = true;
                    } else {
                        logger.info(&quot;Remote regions to fetch modified concurrently,&quot; +
                                &quot; ignoring change from {} to {}&quot;, currentRemoteRegions, latestRemoteRegions);
                    }
                }
            } else {
                // Just refresh mapping to reflect any DNS/Property change
                instanceRegionChecker.getAzToRegionMapper().refreshMapping();
            }
        }

        boolean success = fetchRegistry(remoteRegionsModified);
        if (success) {
            registrySize = localRegionApps.get().size();
            lastSuccessfulRegistryFetchTimestamp = System.currentTimeMillis();
        }

        if (logger.isDebugEnabled()) {
            StringBuilder allAppsHashCodes = new StringBuilder();
            allAppsHashCodes.append(&quot;Local region apps hashcode: &quot;);
            allAppsHashCodes.append(localRegionApps.get().getAppsHashCode());
            allAppsHashCodes.append(&quot;, is fetching remote regions? &quot;);
            allAppsHashCodes.append(isFetchingRemoteRegionRegistries);
            for (Map.Entry&lt;String, Applications&gt; entry : remoteRegionVsApps.entrySet()) {
                allAppsHashCodes.append(&quot;, Remote region: &quot;);
                allAppsHashCodes.append(entry.getKey());
                allAppsHashCodes.append(&quot; , apps hashcode: &quot;);
                allAppsHashCodes.append(entry.getValue().getAppsHashCode());
            }
            logger.debug(&quot;Completed cache refresh task for discovery. All Apps hash code is {} &quot;,
                    allAppsHashCodes);
        }
    } catch (Throwable e) {
        logger.error(&quot;Cannot fetch registry from server&quot;, e);
    }
}
</code></pre>
<h1 id="eureka-性能">Eureka 性能</h1>
<p>https://www.toutiao.com/i6661231047201522183/</p>
<p>http://springcloud.cn/view/31</p>
<p>参考以上两个</p>
<p>从其测试的来看一个Eureka最多支持多少个eureka实例是由操作系统、CPU线程、内存，应用容器连接数等限制的。</p>
<h1 id="问题">问题</h1>
<ol>
<li>一个Eureka Server最支持多少个eureka client?  要看具体的环境操作系统、CPU线程、内存，应用容器连接数等限制的</li>
<li>eureka client的zone与eureka server的zone不一样时，eureka client会向eureka server 注册吗？</li>
<li>。。。</li>
</ol>
<h1 id="eureka-容器化及k8s部署">Eureka 容器化及k8s部署</h1>
<pre><code>---
apiVersion: v1
kind: ConfigMap
metadata:
  name: eureka-cm
  namespace: hjmos
data:
  # if you want to deploy n instances of eureka cluster,
  # you should set eureka_service_address: http://eureka-0.eureka:8761/eureka,...,http://eureka-(n-1).eureka:8761/eureka
  eureka_service_address: http://eureka-0.eureka:8761/eureka,http://eureka-1.eureka:8761/eureka
---
apiVersion: apps/v1beta1
kind: StatefulSet
metadata:
  name: eureka
  namespace: hjmos
spec:
  serviceName: 'eureka'
  replicas: 2
  selector:
    matchLabels:
      app: eureka # 符合目标的Pod有此标签
  template:
    metadata:
      labels:
        app: eureka  # Pod副本的标签
    spec:
      containers:
        - name: service-registry
          image: 10.38.2.12:1000/library/service-registry:1.0.0
          ports:
            - containerPort: 8761
          args:
            - --spring.profiles.active=dev
            - --management.server.port=8081
            - --management.endpoints.web.exposure.include=*
            - --management.endpoint.health.show-details=always
            - --eureka.instance.health-check-url-path=/actuator/health
          env:
            - name: EUREKA_SERVER_ADDRESS
              valueFrom:
                configMapKeyRef:
                  name: eureka-cm
                  key: eureka_service_address

</code></pre>
<p>eureka-cm 存放eureka server集群信息</p>
<pre><code>---
apiVersion: v1
kind: Service
metadata:
  name: eureka
  namespace: hjmos
  labels:
    app: eureka
spec:
  clusterIP: None
  ports:
    - port: 8761
      name: eureka
  selector:
    app: eureka

</code></pre>
<pre><code>apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  name: service-registry-ingress
  annotations:
    kubernetes.io/ingress.class: nginx
    nginx.ingress.kubernetes.io/rewrite-target: /$2
    nginx.ingress.kubernetes.io/use-regex: &quot;true&quot;
    nginx.ingress.kubernetes.io/ssl-redirect: &quot;false&quot;
spec:
  rules:
    - http:
        paths:
          - path: /service-registry(/|$)(.*)
            backend:
              serviceName: eureka
              servicePort: 8761
---
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  name: eureka-ingress
  annotations:
    kubernetes.io/ingress.class: nginx
    nginx.ingress.kubernetes.io/use-regex: &quot;true&quot;
    nginx.ingress.kubernetes.io/ssl-redirect: &quot;false&quot;
spec:
  rules:
    - http:
        paths:
          - path: /eureka
            backend:
              serviceName: eureka
              servicePort: 8761

</code></pre>
<p>外部访问http://ip:port/service-registry, 最好的形式是ingress使用host</p>
<p>Eureka Client有三种形式可以注册到eureka 集群</p>
<ol>
<li>
<p>eureka client和eureka server如果部署在kubernetes的同一个namespace。此时可以使用名为eureka-cm的ConfigMap的eureka_service_address配置数据设置</p>
</li>
<li>
<p>eureka client和eureka server如果部署在同一个kubernetes集群中。此时可以使用headless service的域名地址，这里eureka默认部署在kubernetes的default的命名空间中</p>
<pre><code>eureka:
  client:
    serviceUrl:
      defaultZone: http://eureka-0.eureka.default.svc.cluster.local:8761/eureka/,http://eureka-1.eureka.default.svc.cluster.local:8761/eureka/,http://eureka-2.eureka.default.svc.cluster.local:8761/eureka/
</code></pre>
</li>
<li>
<p>http://ip:port/service-registry</p>
</li>
</ol>

            </div>
          </article>
        </div>
        <div class="paper" data-aos="fade-in">
          
            <div class="next-post">
              <div class="next">
                下一篇
              </div>
              <a href="https://caijh.github.io//post/kubernetes-bu-shu-rabbitmq-ji-qun">
                <h3 class="post-title">
                  kubernetes - 部署rabbitmq集群
                </h3>
              </a>
            </div>
          
        </div>
        
          

          
            <div class="paper" data-aos="fade-in">
              <div id="disqus_thread"></div>
            </div>
          
        
      </div>

      <div class="sm-12 md-4 col sidebar">
  <div class="paper info-container">
    <img src="https://caijh.github.io//images/avatar.png?v=1572851237552" class="no-responsive avatar">
    <div class="text-muted">搬砖小弟</div>
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
  </div>
  <div class="paper">
    <div class="sidebar-title">
      最新文章
    </div>
    <div class="row">
      <ul>
        
          
            <li>
              <a href="https://caijh.github.io//post/spring-cloud-eureka">Spring Cloud - Eureka</a>
            </li>
          
        
          
            <li>
              <a href="https://caijh.github.io//post/kubernetes-bu-shu-rabbitmq-ji-qun">kubernetes - 部署rabbitmq集群</a>
            </li>
          
        
          
            <li>
              <a href="https://caijh.github.io//post/linux-an-zhuang-nfs">Linux - 安装nfs</a>
            </li>
          
        
          
            <li>
              <a href="https://caijh.github.io//post/k8s-an-zhuang-kube-dns-cha-jian">k8s - 安装kube-dns插件</a>
            </li>
          
        
          
            <li>
              <a href="https://caijh.github.io//post/maven-zen-me-yang-skip-test">Maven - 怎么样skip test</a>
            </li>
          
        
          
            <li>
              <a href="https://caijh.github.io//post/k8s-ji-ben-gai-nian">k8s - 基本概念</a>
            </li>
          
        
          
            <li>
              <a href="https://caijh.github.io//post/springboot-qi-dong-yuan-li">SpringBoot - 启动原理</a>
            </li>
          
        
          
            <li>
              <a href="https://caijh.github.io//post/redis-bian-yi-chun-jing-ban">Redis - 编译纯净版</a>
            </li>
          
        
          
            <li>
              <a href="https://caijh.github.io//post/redis-ru-he-fang-wen-da-liang-shu-ju">Redis - 如何访问大量数据</a>
            </li>
          
        
          
            <li>
              <a href="https://caijh.github.io//post/redis-huan-cun-wen-ti">Redis - 缓存问题</a>
            </li>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </ul>
    </div>
  </div>
  <div class="paper">
    <div class="sidebar-title">
      标签列表
    </div>
    <div class="row">
      
        <a href="https://caijh.github.io//tag/Juj0cbeuP" class="badge success">
          docker
        </a>
      
        <a href="https://caijh.github.io//tag/hm42pTrhV" class="badge secondary">
          Maven
        </a>
      
        <a href="https://caijh.github.io//tag/nFkZ3G6Fh" class="badge secondary">
          Java
        </a>
      
        <a href="https://caijh.github.io//tag/6w7rEzKhc" class="badge ">
          Redis
        </a>
      
        <a href="https://caijh.github.io//tag/o82yUqML0" class="badge success">
          MySQL
        </a>
      
        <a href="https://caijh.github.io//tag/cZgK3KqpU" class="badge success">
          源代码
        </a>
      
        <a href="https://caijh.github.io//tag/nHOjalh2s" class="badge warning">
          Spring Cloud
        </a>
      
        <a href="https://caijh.github.io//tag/kmQV6iHOM" class="badge secondary">
          面试
        </a>
      
        <a href="https://caijh.github.io//tag/CymMFfR-7" class="badge secondary">
          设计模式
        </a>
      
    </div>
  </div>
  <div class="paper">
    Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://caijh.github.io//atom.xml" target="_blank">RSS</a>
  </div>
</div>


    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

</script>



  

  
    <script src="https://unpkg.com/disqusjs@1.1/dist/disqus.js"></script>
    <script>

    var options = {
      shortname: 'caijh',
      apikey: 'lO2xchFAyPIP4VOKbgm796D9jIvqLVziAqLHOPnOZySwUlyWXAhgwrIbPQ16AyUX',
    }
    if ('https://disqus.skk.moe/disqus/') {
      options.api = 'https://disqus.skk.moe/disqus/'
    }
    var dsqjs = new DisqusJS(options)

    </script>
  




  </body>
</html>
